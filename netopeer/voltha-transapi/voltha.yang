/*
 * Copyright 2017-present Open Networking Foundation

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module voltha {





    namespace "urn:opencord:params:xml:ns:voltha:voltha";
    prefix voltha;

    organization "CORD";
    contact
        " Any name";

    description
        "";

    revision "2016-11-15" {
        description "Initial revision.";
        reference "reference";
    }


    grouping DeviceGroup {
        description
            "";
        leaf id {
            type  string; 
            description
                "";
        }

        list logical_devices {
            key "id";
            uses  LogicalDevice;

            description
                "";
        }

        list devices {
            key "id";
            uses  Device;

            description
                "";
        }



    }

    grouping DeviceGroups {
        description
            "";
        list items {
            key "id";
            uses  DeviceGroup;

            description
                "";
        }



    }

        typedef AlarmFilterRuleKey {
            type enumeration {
                enum id {
                    description "";
                }
                enum type {
                    description "";
                }
                enum severity {
                    description "";
                }
                enum resource_id {
                    description "";
                }
                enum category {
                    description "";
                }
                enum device_id {
                    description "";
                }
            }
            description
                "";
        }

    grouping AlarmFilterRule {
        description
            "";
        leaf key {
            type  AlarmFilterRuleKey;

            description
                "";
        }

        leaf value {
            type  string; 
            description
                "";
        }



    }

    grouping AlarmFilter {
        description
            "";
        leaf id {
            type  string; 
            description
                "";
        }

        list rules {
            key "key";
            uses  AlarmFilterRule;

            description
                "";
        }



    }

    grouping AlarmFilters {
        description
            "";
        list filters {
            key "id";
            uses  AlarmFilter;

            description
                "";
        }



    }

    container VolthaInstance {
        description
            "Top-level (root) node for a Voltha Instance";
        leaf instance_id {
            type  string; 
            description
                "";
        }

        leaf version {
            type  string; 
            description
                "";
        }

        leaf log_level {
            type  LogLevel;

            description
                "";
        }

        container health {
            uses  HealthStatus;

            description
                "";
        }

        list adapters {
            key "id";
            uses  Adapter;

            description
                "";
        }

        list logical_devices {
            key "id";
            uses  LogicalDevice;

            description
                "";
        }

        list devices {
            key "id";
            uses  Device;

            description
                "";
        }

        list device_types {
            key "id";
            uses  DeviceType;

            description
                "";
        }

        list device_groups {
            key "id";
            uses  DeviceGroup;

            description
                "";
        }

        list alarm_filters {
            key "id";
            uses  AlarmFilter;

            description
                "";
        }



    }

    container VolthaInstances {
        description
            "";
        list items {
            key "items";
            leaf items {
                type  string; 
                description
                    "";
            }
            description
                "";
        }



    }

    container Voltha {
        description
            "Voltha representing the entire Voltha cluster";
        leaf version {
            type  string; 
            description
                "";
        }

        leaf log_level {
            type  LogLevel;

            description
                "";
        }

        list instances {
            key "instance_id";
            uses  VolthaInstance_grouping; 
            description
                "";
        }

        list adapters {
            key "id";
            uses  Adapter;

            description
                "";
        }

        list logical_devices {
            key "id";
            uses  LogicalDevice;

            description
                "";
        }

        list devices {
            key "id";
            uses  Device;

            description
                "";
        }

        list device_groups {
            key "id";
            uses  DeviceGroup;

            description
                "";
        }



    }

    grouping VolthaInstance_grouping {
        description
            "Top-level (root) node for a Voltha Instance";
        leaf instance_id {
            type  string; 
            description
                "";
        }

        leaf version {
            type  string; 
            description
                "";
        }

        leaf log_level {
            type  LogLevel;

            description
                "";
        }

        container health {
            uses  HealthStatus;

            description
                "";
        }

        list adapters {
            key "id";
            uses  Adapter;

            description
                "";
        }

        list logical_devices {
            key "id";
            uses  LogicalDevice;

            description
                "";
        }

        list devices {
            key "id";
            uses  Device;

            description
                "";
        }

        list device_types {
            key "id";
            uses  DeviceType;

            description
                "";
        }

        list device_groups {
            key "id";
            uses  DeviceGroup;

            description
                "";
        }

        list alarm_filters {
            key "id";
            uses  AlarmFilter;

            description
                "";
        }



    }

    grouping VolthaInstances_grouping {
        description
            "";
        list items {
            key "items";
            leaf items {
                type  string; 
                description
                    "";
            }
            description
                "";
        }



    }

    grouping Voltha_grouping {
        description
            "Voltha representing the entire Voltha cluster";
        leaf version {
            type  string; 
            description
                "";
        }

        leaf log_level {
            type  LogLevel;

            description
                "";
        }

        list instances {
            key "instance_id";
            uses  VolthaInstance_grouping; 
            description
                "";
        }

        list adapters {
            key "id";
            uses  Adapter;

            description
                "";
        }

        list logical_devices {
            key "id";
            uses  LogicalDevice;

            description
                "";
        }

        list devices {
            key "id";
            uses  Device;

            description
                "";
        }

        list device_groups {
            key "id";
            uses  DeviceGroup;

            description
                "";
        }



    }

    grouping AdapterConfig {
        description
            "";
        leaf log_level {
            type  LogLevel;

            description
                "Common adapter config attributes here";
        }

        container additional_config {
            uses  Any;

            description
                "Custom (vendor-specific) configuration attributes";
        }



    }

    grouping Adapter {
        description
            "Adapter (software plugin)";
        leaf id {
            type  string;
            description
                "Unique name of adapter, matching the python packate name under
 voltha adapters.";
        }

        leaf vendor {
            type  string;
            description
                "";
        }

        leaf version {
            type  string;
            description
                "";
        }

        container config {
            uses  AdapterConfig;

            description
                "Adapter configuration";
        }

        container additional_description {
            uses  Any;

            description
                "Custom descriptors and custom configuration";
        }

        list logical_device_ids {
            key "logical_device_ids";
            leaf logical_device_ids {
                type  string;
                description
                    "Logical devices  owned ";
            }
            description
                "Logical devices  owned ";
        }



    }

    grouping Adapters {
        description
            "";
        list items {
            key "id";
            uses  Adapter;

            description
                "";
        }



    }

    grouping Any {
        description
            "`Any` contains an arbitrary serialized protocol buffer message along with a
 URL that describes the type of the serialized message.

 Protobuf library provides support to pack unpack Any values in the form
 of utility functions or additional generated methods of the Any type.

 Example 1: Pack and unpack a message in C++.

     Foo foo = ...;
     Any any;
     any.PackFrom(foo);
     ...
     if (any.UnpackTo(&amp;foo))
       ...


 Example 2: Pack and unpack a message in Java.

     Foo foo = ...;
     Any any = Any.pack(foo);
     ...
     if (any.is(Foo.class))
       foo = any.unpack(Foo.class);


  Example 3: Pack and unpack a message in Python.

     foo = Foo(...)
     any = Any()
     any.Pack(foo)
     ...
     if any.Is(Foo.DESCRIPTOR):
       any.Unpack(foo)
       ...

 The pack methods provided by protobuf library will by default use
 'type.googleapis.com full.type.name' as the type URL and the unpack
 methods only use the fully qualified type name after the last ' '
 in the type URL, for example  foo.bar.com x y.z  will yield type
 name  y.z .


 JSON
 ====
 The JSON representation of an `Any` value uses the regular
 representation of the deserialized, embedded message, with an
 additional field `@type` which contains the type URL. Example:

     package google.profile;
     message Person
       string first_name = 1;
       string last_name = 2;



        @type :  type.googleapis.com google.profile.Person ,
        firstName :  string ,
        lastName :  string


 If the embedded message type is well-known and has a custom JSON
 representation, that representation will be embedded adding a field
 `value` which holds the custom JSON in addition to the `@type`
 field. Example (for message  google.protobuf.Duration   ):


        @type :  type.googleapis.com google.protobuf.Duration ,
        value :  1.212s
      ";
        leaf type_url {
            type  string;
            description
                "A URL resource name whose content describes the type of the
 serialized protocol buffer message.

 For URLs which use the scheme `http`, `https`, or no scheme, the
 following restrictions and interpretations apply:

   If no scheme is provided, `https` is assumed.
   The last segment of the URL's path must represent the fully
   qualified name of the type (as in `path google.protobuf.Duration`).
   The name should be in a canonical form (e.g., leading  .  is
   not accepted).
   An HTTP GET on the URL must yield a  google.protobuf.Type
   value in binary format, or produce an error.
   Applications are allowed to cache lookup results based on the
   URL, or have them precompiled into a binary to avoid any
   lookup. Therefore, binary compatibility needs to be preserved
   on changes to types. (Use versioned type names to manage
   breaking changes.)

 Schemes other than `http`, `https` (or the empty scheme) might be
 used with implementation specific semantics.";
        }

        leaf value {
            type  binary;
            description
                "Must be a valid serialized protocol buffer of the above specified type.";
        }



    }

    typedef LogLevel {
        type enumeration {
            enum DEBUG {
                description "";
            }
            enum INFO {
                description "";
            }
            enum WARNING {
                description "";
            }
            enum ERROR {
                description "";
            }
            enum CRITICAL {
                description "";
            }
        }
        description
            "Logging verbosity level";
    }
    typedef AdminState {
        type enumeration {
            enum UNKNOWN {
                description "";
            }
            enum PREPROVISIONED {
                description "";
            }
            enum ENABLED {
                description "";
            }
            enum DISABLED {
                description "";
            }
        }
        description
            "Administrative State";
    }
    typedef OperStatus {
        type enumeration {
            enum UNKNOWN {
                description "";
            }
            enum DISCOVERED {
                description "";
            }
            enum ACTIVATING {
                description "";
            }
            enum TESTING {
                description "";
            }
            enum ACTIVE {
                description "";
            }
            enum FAILED {
                description "";
            }
        }
        description
            "Operational Status";
    }
    typedef ConnectStatus {
        type enumeration {
            enum UNKNOWN {
                description "";
            }
            enum UNREACHABLE {
                description "";
            }
            enum REACHABLE {
                description "";
            }
        }
        description
            "Connectivity Status";
    }

    grouping ID {
        description
            "Convey a resource identifier";
        leaf id {
            type  string;
            description
                "";
        }



    }

    typedef PortType {
        type enumeration {
            enum UNKNOWN {
                description "";
            }
            enum ETHERNET_NNI {
                description "";
            }
            enum ETHERNET_UNI {
                description "";
            }
            enum PON_OLT {
                description "";
            }
            enum PON_ONU {
                description "";
            }
        }
        description
            "";
    }

    grouping DeviceType {
        description
            "A Device Type";
        leaf id {
            type  string;
            description
                "Unique name for the device type";
        }

        leaf adapter {
            type  string;
            description
                "Name of the adapter that handles device type";
        }

        leaf accepts_bulk_flow_update {
            type  boolean;
            description
                "Capabilitities";
        }

        leaf accepts_add_remove_flow_updates {
            type  boolean;
            description
                "";
        }



    }

    grouping DeviceTypes {
        description
            "A plurality of device types";
        list items {
            key "id";
            uses  DeviceType;

            description
                "";
        }



    }

    grouping PmConfig {
        description
            "";
        leaf name {
            type  string;
            description
                "";
        }

        leaf type {
            type  PmType;
            description
                "";
        }

        leaf enabled {
            type  boolean;
            description
                "Whether or not this metric makes it to Kafka";
        }

        leaf sample_freq {
            type  uint32;
            description
                "Sample rate in 10ths of a second";
        }



        typedef PmType {
            type enumeration {
                enum COUNTER {
                    description "";
                }
                enum GUAGE {
                    description "";
                }
                enum STATE {
                    description "";
                }
            }
            description
                "";
        }

    }

    grouping PmGroupConfig {
        description
            "";
        leaf group_name {
            type  string;
            description
                "";
        }

        leaf group_freq {
            type  uint32;
            description
                "Frequency applicable to the grop";
        }

        leaf enabled {
            type  boolean;
            description
                "Enable disable group level only";
        }

        list metrics {
            key "name";
            uses  PmConfig;

            description
                "";
        }



    }

    grouping PmConfigs {
        description
            "";
        leaf id {
            type  string;
            description
                "To work around a chameleon POST bug";
        }

        leaf default_freq {
            type  uint32;
            description
                "Default sample rate";
        }

        leaf grouped {
            type  boolean;
            description
                "Forces group names and group semantics";
        }

        leaf freq_override {
            type  boolean;
            description
                "Allows Pm to set an individual sample frequency";
        }

        list groups {
            key "group_name";
            uses  PmGroupConfig;

            description
                "The groups if grouped is true";
        }

        list metrics {
            key "name";
            uses  PmConfig;

            description
                "The metrics themselves if grouped is false.";
        }



    }

    grouping PeerPort {
        description
            "";
        leaf device_id {
            type  string;
            description
                "";
        }

        leaf port_no {
            type  uint32;
            description
                "";
        }



    }

    grouping Port {
        description
            "";
        leaf port_no {
            type  uint32;
            description
                "Device-unique port number";
        }

        leaf label {
            type  string;
            description
                "Arbitrary port label";
        }

        leaf type {
            type  PortType;
            description
                "Type of port";
        }

        leaf admin_state {
            type  AdminState;

            description
                "";
        }

        leaf oper_status {
            type  OperStatus;

            description
                "";
        }

        leaf device_id {
            type  string;
            description
                "Unique .id of device that owns this port";
        }

        list peers {
            key "device_id";
            uses  PeerPort;
            description
                "";
        }



    }

    grouping Ports {
        description
            "";
        list items {
            key "port_no";
            uses  Port;

            description
                "";
        }



    }

    grouping ProxyAddress {
        description
            "";
        leaf device_id {
            type  string;
            description
                "Which device to use as proxy to this device";
        }

        leaf channel_id {
            type  uint32;
            description
                "Sub-address within proxy";
        }

        leaf onu_id {
            type  uint32;
            description
                "onu identifier; optional";
        }

        leaf onu_session_id {
            type  uint32;
            description
                "session identifier for the ONU; optional";
        }



    }

    grouping Device {
        description
            "A Physical Device instance";
        leaf id {
            type  string;
            description
                "Voltha's device identifier";
        }

        leaf type {
            type  string;
            description
                "Device type, refers to one of the registered device types";
        }

        leaf root {
            type  boolean;
            description
                "Is this device a root device. Each logical switch has one root
 device that is associated with the logical flow switch.";
        }

        leaf parent_id {
            type  string;
            description
                "Parent device id, in the device tree (for a root device, the parent_id
 is the logical_device.id)";
        }

        leaf parent_port_no {
            type  uint32;
            description
                "";
        }

        leaf vendor {
            type  string;
            description
                "Vendor, version, serial number, etc.";
        }

        leaf model {
            type  string;
            description
                "";
        }

        leaf hardware_version {
            type  string;
            description
                "";
        }

        leaf firmware_version {
            type  string;
            description
                "";
        }

        leaf software_version {
            type  string;
            description
                "";
        }

        leaf serial_number {
            type  string;
            description
                "";
        }

        leaf adapter {
            type  string;
            description
                "Addapter that takes care of device";
        }

        leaf vlan {
            type  uint32;
            description
                "Device contact on vlan (if 0, no vlan)";
        }

        container proxy_address {
            uses  ProxyAddress;
            description
                "";
        }

        leaf admin_state {
            type  AdminState;

            description
                "";
        }

        leaf oper_status {
            type  OperStatus;

            description
                "";
        }

        leaf reason {
            type  string;
            description
                "Used in FAILED state";
        }

        leaf connect_status {
            type  ConnectStatus;

            description
                "";
        }

        container custom {
            uses  Any;

            description
                "Device type specific attributes
TODO additional common attribute here";
        }

        list ports {
            key "port_no";
            uses  Port;

            description
                "";
        }

        container flows {
            uses  Flows;

            description
                "";
        }

        container flow_groups {
            uses  FlowGroups;

            description
                "";
        }

        container pm_configs {
            uses  PmConfigs;

            description
                "PmConfigs will eventually converted to a child node of the
 device to falicitata callbacks and to simplify manipulation.";
        }



        choice choice_0 {
            case mac_address {
                leaf mac_address {
                    type  string;
                    description
                        "Device contact MAC address (format:  xx:xx:xx:xx:xx:xx )";
                }
            }
            case ipv4_address {
                leaf ipv4_address {
                    type  string;
                    description
                        "Device contact IPv4 address (format:  a.b.c.d  or can use hostname too)";
                }
            }
            case ipv6_address {
                leaf ipv6_address {
                    type  string;
                    description
                        "Device contact IPv6 address using the canonical string form
 ( xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx )";
                }
            }
            case host_and_port {
                leaf host_and_port {
                    type  string;
                    description
                        "";
                }
            }
        }


    }

    grouping Devices {
        description
            "";
        list items {
            key "id";
            uses  Device;

            description
                "";
        }



    }


    grouping Empty {
        description
            "A generic empty message that you can re-use to avoid defining duplicated
 empty messages in your APIs. A typical example is to use it as the request
 or the response type of an API method. For instance:

     service Foo
       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);


 The JSON representation for `Empty` is empty JSON object `  `.";


    }


    grouping HealthStatus {
        description
            "Encode health status of a Voltha instance";
        leaf state {
            type  HealthState;
            description
                "Current state of health of this Voltha instance";
        }



        typedef HealthState {
            type enumeration {
                enum HEALTHY {
                    description "";
                }
                enum OVERLOADED {
                    description "";
                }
                enum DYING {
                    description "";
                }
            }
            description
                "Health states";
        }

    }

    grouping LogicalPort {
        description
            "";
        leaf id {
            type  string;
            description
                "";
        }

        container ofp_port {
            uses  ofp_port;

            description
                "";
        }

        leaf device_id {
            type  string;
            description
                "";
        }

        leaf device_port_no {
            type  uint32;
            description
                "";
        }

        leaf root_port {
            type  boolean;
            description
                "";
        }



    }

    grouping LogicalPorts {
        description
            "";
        list items {
            key "id";
            uses  LogicalPort;

            description
                "";
        }



    }

    grouping LogicalDevice {
        description
            "";
        leaf id {
            type  string;
            description
                "unique id of logical device";
        }

        leaf datapath_id {
            type  uint64;
            description
                "unique datapath id for the logical device (used by the SDN controller)";
        }

        container desc {
            uses  ofp_desc;

            description
                "device description";
        }

        container switch_features {
            uses  ofp_switch_features;

            description
                "device features";
        }

        leaf root_device_id {
            type  string;
            description
                "name of the root device anchoring logical device";
        }

        list ports {
            key "id";
            uses  LogicalPort;

            description
                "logical device ports";
        }

        container flows {
            uses  Flows;

            description
                "flows configured on the logical device";
        }

        container flow_groups {
            uses  FlowGroups;

            description
                "flow groups configured on the logical device";
        }



    }

    grouping LogicalDevices {
        description
            "";
        list items {
            key "id";
            uses  LogicalDevice;

            description
                "";
        }



    }


    typedef Access {
        type enumeration {
            enum CONFIG {
                description "";
            }
            enum READ_ONLY {
                description "";
            }
            enum REAL_TIME {
                description "";
            }
        }
        description
            "";
    }

    container ChildNode {
        description
            "";
        leaf key {
            type  string;
            description
                "";
        }



    }

    typedef ofp_port_no {
        type enumeration {
            enum OFPP_INVALID {
                description "";
            }
            enum OFPP_MAX {
                description "";
            }
            enum OFPP_IN_PORT {
                description "";
            }
            enum OFPP_TABLE {
                description "";
            }
            enum OFPP_NORMAL {
                description "";
            }
            enum OFPP_FLOOD {
                description "";
            }
            enum OFPP_ALL {
                description "";
            }
            enum OFPP_CONTROLLER {
                description "";
            }
            enum OFPP_LOCAL {
                description "";
            }
            enum OFPP_ANY {
                description "";
            }
        }
        description
            "Port numbering. Ports are numbered starting from 1.Version number:
 OpenFlow versions released: 0x01 = 1.0 ; 0x02 = 1.1 ; 0x03 = 1.2
     0x04 = 1.3
The most significant bit in the version field is reserved and must
 be set to zero.
#define OFP_VERSION   0x04
#define PIPELINE_TABLES 64
#define OFP_MAX_TABLE_NAME_LEN 32
#define OFP_MAX_PORT_NAME_LEN  16
Official IANA registered port for OpenFlow.#define OFP_TCP_PORT  6653
#define OFP_SSL_PORT  6653
#define OFP_ETH_ALEN 6             Bytes in an Ethernet address.   ";
    }
    typedef ofp_type {
        type enumeration {
            enum OFPT_HELLO {
                description "";
            }
            enum OFPT_ERROR {
                description "";
            }
            enum OFPT_ECHO_REQUEST {
                description "";
            }
            enum OFPT_ECHO_REPLY {
                description "";
            }
            enum OFPT_EXPERIMENTER {
                description "";
            }
            enum OFPT_FEATURES_REQUEST {
                description "";
            }
            enum OFPT_FEATURES_REPLY {
                description "";
            }
            enum OFPT_GET_CONFIG_REQUEST {
                description "";
            }
            enum OFPT_GET_CONFIG_REPLY {
                description "";
            }
            enum OFPT_SET_CONFIG {
                description "";
            }
            enum OFPT_PACKET_IN {
                description "";
            }
            enum OFPT_FLOW_REMOVED {
                description "";
            }
            enum OFPT_PORT_STATUS {
                description "";
            }
            enum OFPT_PACKET_OUT {
                description "";
            }
            enum OFPT_FLOW_MOD {
                description "";
            }
            enum OFPT_GROUP_MOD {
                description "";
            }
            enum OFPT_PORT_MOD {
                description "";
            }
            enum OFPT_TABLE_MOD {
                description "";
            }
            enum OFPT_MULTIPART_REQUEST {
                description "";
            }
            enum OFPT_MULTIPART_REPLY {
                description "";
            }
            enum OFPT_BARRIER_REQUEST {
                description "";
            }
            enum OFPT_BARRIER_REPLY {
                description "";
            }
            enum OFPT_QUEUE_GET_CONFIG_REQUEST {
                description "";
            }
            enum OFPT_QUEUE_GET_CONFIG_REPLY {
                description "";
            }
            enum OFPT_ROLE_REQUEST {
                description "";
            }
            enum OFPT_ROLE_REPLY {
                description "";
            }
            enum OFPT_GET_ASYNC_REQUEST {
                description "";
            }
            enum OFPT_GET_ASYNC_REPLY {
                description "";
            }
            enum OFPT_SET_ASYNC {
                description "";
            }
            enum OFPT_METER_MOD {
                description "";
            }
        }
        description
            "";
    }
    typedef ofp_hello_elem_type {
        type enumeration {
            enum OFPHET_INVALID {
                description "";
            }
            enum OFPHET_VERSIONBITMAP {
                description "";
            }
        }
        description
            "Hello elements types.";
    }
    typedef ofp_config_flags {
        type enumeration {
            enum OFPC_FRAG_NORMAL {
                description "";
            }
            enum OFPC_FRAG_DROP {
                description "";
            }
            enum OFPC_FRAG_REASM {
                description "";
            }
            enum OFPC_FRAG_MASK {
                description "";
            }
        }
        description
            "#define OFP_DEFAULT_MISS_SEND_LEN   128";
    }
    typedef ofp_table_config {
        type enumeration {
            enum OFPTC_INVALID {
                description "";
            }
            enum OFPTC_DEPRECATED_MASK {
                description "";
            }
        }
        description
            "Flags to configure the table. Reserved for future use.";
    }
    typedef ofp_table {
        type enumeration {
            enum OFPTT_INVALID {
                description "";
            }
            enum OFPTT_MAX {
                description "";
            }
            enum OFPTT_ALL {
                description "";
            }
        }
        description
            "Table numbering. Tables can use any number up to OFPT_MAX.";
    }
    typedef ofp_capabilities {
        type enumeration {
            enum OFPC_INVALID {
                description "";
            }
            enum OFPC_FLOW_STATS {
                description "";
            }
            enum OFPC_TABLE_STATS {
                description "";
            }
            enum OFPC_PORT_STATS {
                description "";
            }
            enum OFPC_GROUP_STATS {
                description "";
            }
            enum OFPC_IP_REASM {
                description "";
            }
            enum OFPC_QUEUE_STATS {
                description "";
            }
            enum OFPC_PORT_BLOCKED {
                description "";
            }
        }
        description
            "Capabilities supported by the datapath.";
    }
    typedef ofp_port_config {
        type enumeration {
            enum OFPPC_INVALID {
                description "";
            }
            enum OFPPC_PORT_DOWN {
                description "";
            }
            enum OFPPC_NO_RECV {
                description "";
            }
            enum OFPPC_NO_FWD {
                description "";
            }
            enum OFPPC_NO_PACKET_IN {
                description "";
            }
        }
        description
            "Flags to indicate behavior of the physical port.  These flags are
 used in ofp_port to describe the current configuration.  They are
 used in the ofp_port_mod message to configure the port's behavior.";
    }
    typedef ofp_port_state {
        type enumeration {
            enum OFPPS_INVALID {
                description "";
            }
            enum OFPPS_LINK_DOWN {
                description "";
            }
            enum OFPPS_BLOCKED {
                description "";
            }
            enum OFPPS_LIVE {
                description "";
            }
        }
        description
            "Current state of the physical port.  These are not configurable from
 the controller.";
    }
    typedef ofp_port_features {
        type enumeration {
            enum OFPPF_INVALID {
                description "";
            }
            enum OFPPF_10MB_HD {
                description "";
            }
            enum OFPPF_10MB_FD {
                description "";
            }
            enum OFPPF_100MB_HD {
                description "";
            }
            enum OFPPF_100MB_FD {
                description "";
            }
            enum OFPPF_1GB_HD {
                description "";
            }
            enum OFPPF_1GB_FD {
                description "";
            }
            enum OFPPF_10GB_FD {
                description "";
            }
            enum OFPPF_40GB_FD {
                description "";
            }
            enum OFPPF_100GB_FD {
                description "";
            }
            enum OFPPF_1TB_FD {
                description "";
            }
            enum OFPPF_OTHER {
                description "";
            }
            enum OFPPF_COPPER {
                description "";
            }
            enum OFPPF_FIBER {
                description "";
            }
            enum OFPPF_AUTONEG {
                description "";
            }
            enum OFPPF_PAUSE {
                description "";
            }
            enum OFPPF_PAUSE_ASYM {
                description "";
            }
        }
        description
            "Features of ports available in a datapath.";
    }
    typedef ofp_port_reason {
        type enumeration {
            enum OFPPR_ADD {
                description "";
            }
            enum OFPPR_DELETE {
                description "";
            }
            enum OFPPR_MODIFY {
                description "";
            }
        }
        description
            "What changed about the physical port";
    }
    typedef ofp_match_type {
        type enumeration {
            enum OFPMT_STANDARD {
                description "";
            }
            enum OFPMT_OXM {
                description "";
            }
        }
        description
            "The match type indicates the match structure (set of fields that compose the
 match) in use. The match type is placed in the type field at the beginning
 of all match structures. The  OpenFlow Extensible Match  type corresponds
 to OXM TLV format described below and must be supported by all OpenFlow
 switches. Extensions that define other match types may be published on the
 ONF wiki. Support for extensions is optional.
## -------------------------- #### OpenFlow Extensible Match. #### -------------------------- ##";
    }
    typedef ofp_oxm_class {
        type enumeration {
            enum OFPXMC_NXM_0 {
                description "";
            }
            enum OFPXMC_NXM_1 {
                description "";
            }
            enum OFPXMC_OPENFLOW_BASIC {
                description "";
            }
            enum OFPXMC_EXPERIMENTER {
                description "";
            }
        }
        description
            "OXM Class IDs.
 The high order bit differentiate reserved classes from member classes.
 Classes 0x0000 to 0x7FFF are member classes, allocated by ONF.
 Classes 0x8000 to 0xFFFE are reserved classes, reserved for standardisation.
Components of a OXM TLV header.
 Those macros are not valid for the experimenter class, macros for the
 experimenter class will depend on the experimenter header used.#define OXM_HEADER__(CLASS, FIELD, HASMASK, LENGTH)
    (((CLASS)    16) | ((FIELD)    9) | ((HASMASK)    8) | (LENGTH))
#define OXM_HEADER(CLASS, FIELD, LENGTH)
    OXM_HEADER__(CLASS, FIELD, 0, LENGTH)
#define OXM_HEADER_W(CLASS, FIELD, LENGTH)
    OXM_HEADER__(CLASS, FIELD, 1, (LENGTH)   2)
#define OXM_CLASS(HEADER) ((HEADER)    16)
#define OXM_FIELD(HEADER) (((HEADER)    9) &amp; 0x7f)
#define OXM_TYPE(HEADER) (((HEADER)    9) &amp; 0x7fffff)
#define OXM_HASMASK(HEADER) (((HEADER)    8) &amp; 1)
#define OXM_LENGTH(HEADER) ((HEADER) &amp; 0xff)

#define OXM_MAKE_WILD_HEADER(HEADER)
    OXM_HEADER_W(OXM_CLASS(HEADER), OXM_FIELD(HEADER), OXM_LENGTH(HEADER))";
    }
    typedef oxm_ofb_field_types {
        type enumeration {
            enum OFPXMT_OFB_IN_PORT {
                description "";
            }
            enum OFPXMT_OFB_IN_PHY_PORT {
                description "";
            }
            enum OFPXMT_OFB_METADATA {
                description "";
            }
            enum OFPXMT_OFB_ETH_DST {
                description "";
            }
            enum OFPXMT_OFB_ETH_SRC {
                description "";
            }
            enum OFPXMT_OFB_ETH_TYPE {
                description "";
            }
            enum OFPXMT_OFB_VLAN_VID {
                description "";
            }
            enum OFPXMT_OFB_VLAN_PCP {
                description "";
            }
            enum OFPXMT_OFB_IP_DSCP {
                description "";
            }
            enum OFPXMT_OFB_IP_ECN {
                description "";
            }
            enum OFPXMT_OFB_IP_PROTO {
                description "";
            }
            enum OFPXMT_OFB_IPV4_SRC {
                description "";
            }
            enum OFPXMT_OFB_IPV4_DST {
                description "";
            }
            enum OFPXMT_OFB_TCP_SRC {
                description "";
            }
            enum OFPXMT_OFB_TCP_DST {
                description "";
            }
            enum OFPXMT_OFB_UDP_SRC {
                description "";
            }
            enum OFPXMT_OFB_UDP_DST {
                description "";
            }
            enum OFPXMT_OFB_SCTP_SRC {
                description "";
            }
            enum OFPXMT_OFB_SCTP_DST {
                description "";
            }
            enum OFPXMT_OFB_ICMPV4_TYPE {
                description "";
            }
            enum OFPXMT_OFB_ICMPV4_CODE {
                description "";
            }
            enum OFPXMT_OFB_ARP_OP {
                description "";
            }
            enum OFPXMT_OFB_ARP_SPA {
                description "";
            }
            enum OFPXMT_OFB_ARP_TPA {
                description "";
            }
            enum OFPXMT_OFB_ARP_SHA {
                description "";
            }
            enum OFPXMT_OFB_ARP_THA {
                description "";
            }
            enum OFPXMT_OFB_IPV6_SRC {
                description "";
            }
            enum OFPXMT_OFB_IPV6_DST {
                description "";
            }
            enum OFPXMT_OFB_IPV6_FLABEL {
                description "";
            }
            enum OFPXMT_OFB_ICMPV6_TYPE {
                description "";
            }
            enum OFPXMT_OFB_ICMPV6_CODE {
                description "";
            }
            enum OFPXMT_OFB_IPV6_ND_TARGET {
                description "";
            }
            enum OFPXMT_OFB_IPV6_ND_SLL {
                description "";
            }
            enum OFPXMT_OFB_IPV6_ND_TLL {
                description "";
            }
            enum OFPXMT_OFB_MPLS_LABEL {
                description "";
            }
            enum OFPXMT_OFB_MPLS_TC {
                description "";
            }
            enum OFPXMT_OFB_MPLS_BOS {
                description "";
            }
            enum OFPXMT_OFB_PBB_ISID {
                description "";
            }
            enum OFPXMT_OFB_TUNNEL_ID {
                description "";
            }
            enum OFPXMT_OFB_IPV6_EXTHDR {
                description "";
            }
        }
        description
            "OXM Flow field types for OpenFlow basic class.";
    }
    typedef ofp_vlan_id {
        type enumeration {
            enum OFPVID_NONE {
                description "";
            }
            enum OFPVID_PRESENT {
                description "";
            }
        }
        description
            "The VLAN id is 12-bits, so we can use the entire 16 bits to indicate
 special conditions.";
    }
    typedef ofp_ipv6exthdr_flags {
        type enumeration {
            enum OFPIEH_INVALID {
                description "";
            }
            enum OFPIEH_NONEXT {
                description "";
            }
            enum OFPIEH_ESP {
                description "";
            }
            enum OFPIEH_AUTH {
                description "";
            }
            enum OFPIEH_DEST {
                description "";
            }
            enum OFPIEH_FRAG {
                description "";
            }
            enum OFPIEH_ROUTER {
                description "";
            }
            enum OFPIEH_HOP {
                description "";
            }
            enum OFPIEH_UNREP {
                description "";
            }
            enum OFPIEH_UNSEQ {
                description "";
            }
        }
        description
            "Bit definitions for IPv6 Extension Header pseudo-field.#define OFP_VLAN_NONE      OFPVID_NONE";
    }
    typedef ofp_action_type {
        type enumeration {
            enum OFPAT_OUTPUT {
                description "";
            }
            enum OFPAT_COPY_TTL_OUT {
                description "";
            }
            enum OFPAT_COPY_TTL_IN {
                description "";
            }
            enum OFPAT_SET_MPLS_TTL {
                description "";
            }
            enum OFPAT_DEC_MPLS_TTL {
                description "";
            }
            enum OFPAT_PUSH_VLAN {
                description "";
            }
            enum OFPAT_POP_VLAN {
                description "";
            }
            enum OFPAT_PUSH_MPLS {
                description "";
            }
            enum OFPAT_POP_MPLS {
                description "";
            }
            enum OFPAT_SET_QUEUE {
                description "";
            }
            enum OFPAT_GROUP {
                description "";
            }
            enum OFPAT_SET_NW_TTL {
                description "";
            }
            enum OFPAT_DEC_NW_TTL {
                description "";
            }
            enum OFPAT_SET_FIELD {
                description "";
            }
            enum OFPAT_PUSH_PBB {
                description "";
            }
            enum OFPAT_POP_PBB {
                description "";
            }
            enum OFPAT_EXPERIMENTER {
                description "";
            }
        }
        description
            "## ----------------- #### OpenFlow Actions. #### ----------------- ##";
    }
    typedef ofp_controller_max_len {
        type enumeration {
            enum OFPCML_INVALID {
                description "";
            }
            enum OFPCML_MAX {
                description "";
            }
            enum OFPCML_NO_BUFFER {
                description "";
            }
        }
        description
            "";
    }
    typedef ofp_instruction_type {
        type enumeration {
            enum OFPIT_INVALID {
                description "";
            }
            enum OFPIT_GOTO_TABLE {
                description "";
            }
            enum OFPIT_WRITE_METADATA {
                description "";
            }
            enum OFPIT_WRITE_ACTIONS {
                description "";
            }
            enum OFPIT_APPLY_ACTIONS {
                description "";
            }
            enum OFPIT_CLEAR_ACTIONS {
                description "";
            }
            enum OFPIT_METER {
                description "";
            }
            enum OFPIT_EXPERIMENTER {
                description "";
            }
        }
        description
            "## ---------------------- #### OpenFlow Instructions. #### ---------------------- ##";
    }
    typedef ofp_flow_mod_command {
        type enumeration {
            enum OFPFC_ADD {
                description "";
            }
            enum OFPFC_MODIFY {
                description "";
            }
            enum OFPFC_MODIFY_STRICT {
                description "";
            }
            enum OFPFC_DELETE {
                description "";
            }
            enum OFPFC_DELETE_STRICT {
                description "";
            }
        }
        description
            "## --------------------------- #### OpenFlow Flow Modification. #### --------------------------- ##";
    }
    typedef ofp_flow_mod_flags {
        type enumeration {
            enum OFPFF_INVALID {
                description "";
            }
            enum OFPFF_SEND_FLOW_REM {
                description "";
            }
            enum OFPFF_CHECK_OVERLAP {
                description "";
            }
            enum OFPFF_RESET_COUNTS {
                description "";
            }
            enum OFPFF_NO_PKT_COUNTS {
                description "";
            }
            enum OFPFF_NO_BYT_COUNTS {
                description "";
            }
        }
        description
            "Value used in  idle_timeout  and  hard_timeout  to indicate that the entry
 is permanent.#define OFP_FLOW_PERMANENT 0
By default, choose a priority in the middle.#define OFP_DEFAULT_PRIORITY 0x8000";
    }
    typedef ofp_group {
        type enumeration {
            enum OFPG_INVALID {
                description "";
            }
            enum OFPG_MAX {
                description "";
            }
            enum OFPG_ALL {
                description "";
            }
            enum OFPG_ANY {
                description "";
            }
        }
        description
            "Group numbering. Groups can use any number up to OFPG_MAX.";
    }
    typedef ofp_group_mod_command {
        type enumeration {
            enum OFPGC_ADD {
                description "";
            }
            enum OFPGC_MODIFY {
                description "";
            }
            enum OFPGC_DELETE {
                description "";
            }
        }
        description
            "Group commands";
    }
    typedef ofp_group_type {
        type enumeration {
            enum OFPGT_ALL {
                description "";
            }
            enum OFPGT_SELECT {
                description "";
            }
            enum OFPGT_INDIRECT {
                description "";
            }
            enum OFPGT_FF {
                description "";
            }
        }
        description
            "Group types.  Values in the range  128; 255  are reserved for experimental
 use.";
    }
    typedef ofp_packet_in_reason {
        type enumeration {
            enum OFPR_NO_MATCH {
                description "";
            }
            enum OFPR_ACTION {
                description "";
            }
            enum OFPR_INVALID_TTL {
                description "";
            }
        }
        description
            "Why is this packet being sent to the controller?";
    }
    typedef ofp_flow_removed_reason {
        type enumeration {
            enum OFPRR_IDLE_TIMEOUT {
                description "";
            }
            enum OFPRR_HARD_TIMEOUT {
                description "";
            }
            enum OFPRR_DELETE {
                description "";
            }
            enum OFPRR_GROUP_DELETE {
                description "";
            }
            enum OFPRR_METER_DELETE {
                description "";
            }
        }
        description
            "Why was this flow removed?";
    }
    typedef ofp_meter {
        type enumeration {
            enum OFPM_ZERO {
                description "";
            }
            enum OFPM_MAX {
                description "";
            }
            enum OFPM_SLOWPATH {
                description "";
            }
            enum OFPM_CONTROLLER {
                description "";
            }
            enum OFPM_ALL {
                description "";
            }
        }
        description
            "Meter numbering. Flow meters can use any number up to OFPM_MAX.";
    }
    typedef ofp_meter_band_type {
        type enumeration {
            enum OFPMBT_INVALID {
                description "";
            }
            enum OFPMBT_DROP {
                description "";
            }
            enum OFPMBT_DSCP_REMARK {
                description "";
            }
            enum OFPMBT_EXPERIMENTER {
                description "";
            }
        }
        description
            "Meter band types";
    }
    typedef ofp_meter_mod_command {
        type enumeration {
            enum OFPMC_ADD {
                description "";
            }
            enum OFPMC_MODIFY {
                description "";
            }
            enum OFPMC_DELETE {
                description "";
            }
        }
        description
            "Meter commands";
    }
    typedef ofp_meter_flags {
        type enumeration {
            enum OFPMF_INVALID {
                description "";
            }
            enum OFPMF_KBPS {
                description "";
            }
            enum OFPMF_PKTPS {
                description "";
            }
            enum OFPMF_BURST {
                description "";
            }
            enum OFPMF_STATS {
                description "";
            }
        }
        description
            "Meter configuration flags";
    }
    typedef ofp_error_type {
        type enumeration {
            enum OFPET_HELLO_FAILED {
                description "";
            }
            enum OFPET_BAD_REQUEST {
                description "";
            }
            enum OFPET_BAD_ACTION {
                description "";
            }
            enum OFPET_BAD_INSTRUCTION {
                description "";
            }
            enum OFPET_BAD_MATCH {
                description "";
            }
            enum OFPET_FLOW_MOD_FAILED {
                description "";
            }
            enum OFPET_GROUP_MOD_FAILED {
                description "";
            }
            enum OFPET_PORT_MOD_FAILED {
                description "";
            }
            enum OFPET_TABLE_MOD_FAILED {
                description "";
            }
            enum OFPET_QUEUE_OP_FAILED {
                description "";
            }
            enum OFPET_SWITCH_CONFIG_FAILED {
                description "";
            }
            enum OFPET_ROLE_REQUEST_FAILED {
                description "";
            }
            enum OFPET_METER_MOD_FAILED {
                description "";
            }
            enum OFPET_TABLE_FEATURES_FAILED {
                description "";
            }
            enum OFPET_EXPERIMENTER {
                description "";
            }
        }
        description
            "Values for 'type' in ofp_error_message.  These values are immutable: they
 will not change in future versions of the protocol (although new values may
 be added).";
    }
    typedef ofp_hello_failed_code {
        type enumeration {
            enum OFPHFC_INCOMPATIBLE {
                description "";
            }
            enum OFPHFC_EPERM {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_HELLO_FAILED.  'data' contains an
 ASCII text string that may give failure details.";
    }
    typedef ofp_bad_request_code {
        type enumeration {
            enum OFPBRC_BAD_VERSION {
                description "";
            }
            enum OFPBRC_BAD_TYPE {
                description "";
            }
            enum OFPBRC_BAD_MULTIPART {
                description "";
            }
            enum OFPBRC_BAD_EXPERIMENTER {
                description "";
            }
            enum OFPBRC_BAD_EXP_TYPE {
                description "";
            }
            enum OFPBRC_EPERM {
                description "";
            }
            enum OFPBRC_BAD_LEN {
                description "";
            }
            enum OFPBRC_BUFFER_EMPTY {
                description "";
            }
            enum OFPBRC_BUFFER_UNKNOWN {
                description "";
            }
            enum OFPBRC_BAD_TABLE_ID {
                description "";
            }
            enum OFPBRC_IS_SLAVE {
                description "";
            }
            enum OFPBRC_BAD_PORT {
                description "";
            }
            enum OFPBRC_BAD_PACKET {
                description "";
            }
            enum OFPBRC_MULTIPART_BUFFER_OVERFLOW {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_BAD_REQUEST.  'data' contains at least
 the first 64 bytes of the failed request.";
    }
    typedef ofp_bad_action_code {
        type enumeration {
            enum OFPBAC_BAD_TYPE {
                description "";
            }
            enum OFPBAC_BAD_LEN {
                description "";
            }
            enum OFPBAC_BAD_EXPERIMENTER {
                description "";
            }
            enum OFPBAC_BAD_EXP_TYPE {
                description "";
            }
            enum OFPBAC_BAD_OUT_PORT {
                description "";
            }
            enum OFPBAC_BAD_ARGUMENT {
                description "";
            }
            enum OFPBAC_EPERM {
                description "";
            }
            enum OFPBAC_TOO_MANY {
                description "";
            }
            enum OFPBAC_BAD_QUEUE {
                description "";
            }
            enum OFPBAC_BAD_OUT_GROUP {
                description "";
            }
            enum OFPBAC_MATCH_INCONSISTENT {
                description "";
            }
            enum OFPBAC_UNSUPPORTED_ORDER {
                description "";
            }
            enum OFPBAC_BAD_TAG {
                description "";
            }
            enum OFPBAC_BAD_SET_TYPE {
                description "";
            }
            enum OFPBAC_BAD_SET_LEN {
                description "";
            }
            enum OFPBAC_BAD_SET_ARGUMENT {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_BAD_ACTION.  'data' contains at least
 the first 64 bytes of the failed request.";
    }
    typedef ofp_bad_instruction_code {
        type enumeration {
            enum OFPBIC_UNKNOWN_INST {
                description "";
            }
            enum OFPBIC_UNSUP_INST {
                description "";
            }
            enum OFPBIC_BAD_TABLE_ID {
                description "";
            }
            enum OFPBIC_UNSUP_METADATA {
                description "";
            }
            enum OFPBIC_UNSUP_METADATA_MASK {
                description "";
            }
            enum OFPBIC_BAD_EXPERIMENTER {
                description "";
            }
            enum OFPBIC_BAD_EXP_TYPE {
                description "";
            }
            enum OFPBIC_BAD_LEN {
                description "";
            }
            enum OFPBIC_EPERM {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_BAD_INSTRUCTION.  'data' contains at
 least the first 64 bytes of the failed request.";
    }
    typedef ofp_bad_match_code {
        type enumeration {
            enum OFPBMC_BAD_TYPE {
                description "";
            }
            enum OFPBMC_BAD_LEN {
                description "";
            }
            enum OFPBMC_BAD_TAG {
                description "";
            }
            enum OFPBMC_BAD_DL_ADDR_MASK {
                description "";
            }
            enum OFPBMC_BAD_NW_ADDR_MASK {
                description "";
            }
            enum OFPBMC_BAD_WILDCARDS {
                description "";
            }
            enum OFPBMC_BAD_FIELD {
                description "";
            }
            enum OFPBMC_BAD_VALUE {
                description "";
            }
            enum OFPBMC_BAD_MASK {
                description "";
            }
            enum OFPBMC_BAD_PREREQ {
                description "";
            }
            enum OFPBMC_DUP_FIELD {
                description "";
            }
            enum OFPBMC_EPERM {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_BAD_MATCH.  'data' contains at least
 the first 64 bytes of the failed request.";
    }
    typedef ofp_flow_mod_failed_code {
        type enumeration {
            enum OFPFMFC_UNKNOWN {
                description "";
            }
            enum OFPFMFC_TABLE_FULL {
                description "";
            }
            enum OFPFMFC_BAD_TABLE_ID {
                description "";
            }
            enum OFPFMFC_OVERLAP {
                description "";
            }
            enum OFPFMFC_EPERM {
                description "";
            }
            enum OFPFMFC_BAD_TIMEOUT {
                description "";
            }
            enum OFPFMFC_BAD_COMMAND {
                description "";
            }
            enum OFPFMFC_BAD_FLAGS {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_FLOW_MOD_FAILED.  'data' contains
 at least the first 64 bytes of the failed request.";
    }
    typedef ofp_group_mod_failed_code {
        type enumeration {
            enum OFPGMFC_GROUP_EXISTS {
                description "";
            }
            enum OFPGMFC_INVALID_GROUP {
                description "";
            }
            enum OFPGMFC_WEIGHT_UNSUPPORTED {
                description "";
            }
            enum OFPGMFC_OUT_OF_GROUPS {
                description "";
            }
            enum OFPGMFC_OUT_OF_BUCKETS {
                description "";
            }
            enum OFPGMFC_CHAINING_UNSUPPORTED {
                description "";
            }
            enum OFPGMFC_WATCH_UNSUPPORTED {
                description "";
            }
            enum OFPGMFC_LOOP {
                description "";
            }
            enum OFPGMFC_UNKNOWN_GROUP {
                description "";
            }
            enum OFPGMFC_CHAINED_GROUP {
                description "";
            }
            enum OFPGMFC_BAD_TYPE {
                description "";
            }
            enum OFPGMFC_BAD_COMMAND {
                description "";
            }
            enum OFPGMFC_BAD_BUCKET {
                description "";
            }
            enum OFPGMFC_BAD_WATCH {
                description "";
            }
            enum OFPGMFC_EPERM {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_GROUP_MOD_FAILED.  'data' contains
 at least the first 64 bytes of the failed request.";
    }
    typedef ofp_port_mod_failed_code {
        type enumeration {
            enum OFPPMFC_BAD_PORT {
                description "";
            }
            enum OFPPMFC_BAD_HW_ADDR {
                description "";
            }
            enum OFPPMFC_BAD_CONFIG {
                description "";
            }
            enum OFPPMFC_BAD_ADVERTISE {
                description "";
            }
            enum OFPPMFC_EPERM {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_PORT_MOD_FAILED.  'data' contains
 at least the first 64 bytes of the failed request.";
    }
    typedef ofp_table_mod_failed_code {
        type enumeration {
            enum OFPTMFC_BAD_TABLE {
                description "";
            }
            enum OFPTMFC_BAD_CONFIG {
                description "";
            }
            enum OFPTMFC_EPERM {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_TABLE_MOD_FAILED.  'data' contains
 at least the first 64 bytes of the failed request.";
    }
    typedef ofp_queue_op_failed_code {
        type enumeration {
            enum OFPQOFC_BAD_PORT {
                description "";
            }
            enum OFPQOFC_BAD_QUEUE {
                description "";
            }
            enum OFPQOFC_EPERM {
                description "";
            }
        }
        description
            "ofp_error msg 'code' values for OFPET_QUEUE_OP_FAILED. 'data' contains
 at least the first 64 bytes of the failed request";
    }
    typedef ofp_switch_config_failed_code {
        type enumeration {
            enum OFPSCFC_BAD_FLAGS {
                description "";
            }
            enum OFPSCFC_BAD_LEN {
                description "";
            }
            enum OFPSCFC_EPERM {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_SWITCH_CONFIG_FAILED. 'data' contains
 at least the first 64 bytes of the failed request.";
    }
    typedef ofp_role_request_failed_code {
        type enumeration {
            enum OFPRRFC_STALE {
                description "";
            }
            enum OFPRRFC_UNSUP {
                description "";
            }
            enum OFPRRFC_BAD_ROLE {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_ROLE_REQUEST_FAILED. 'data' contains
 at least the first 64 bytes of the failed request.";
    }
    typedef ofp_meter_mod_failed_code {
        type enumeration {
            enum OFPMMFC_UNKNOWN {
                description "";
            }
            enum OFPMMFC_METER_EXISTS {
                description "";
            }
            enum OFPMMFC_INVALID_METER {
                description "";
            }
            enum OFPMMFC_UNKNOWN_METER {
                description "";
            }
            enum OFPMMFC_BAD_COMMAND {
                description "";
            }
            enum OFPMMFC_BAD_FLAGS {
                description "";
            }
            enum OFPMMFC_BAD_RATE {
                description "";
            }
            enum OFPMMFC_BAD_BURST {
                description "";
            }
            enum OFPMMFC_BAD_BAND {
                description "";
            }
            enum OFPMMFC_BAD_BAND_VALUE {
                description "";
            }
            enum OFPMMFC_OUT_OF_METERS {
                description "";
            }
            enum OFPMMFC_OUT_OF_BANDS {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_METER_MOD_FAILED.  'data' contains
 at least the first 64 bytes of the failed request.";
    }
    typedef ofp_table_features_failed_code {
        type enumeration {
            enum OFPTFFC_BAD_TABLE {
                description "";
            }
            enum OFPTFFC_BAD_METADATA {
                description "";
            }
            enum OFPTFFC_BAD_TYPE {
                description "";
            }
            enum OFPTFFC_BAD_LEN {
                description "";
            }
            enum OFPTFFC_BAD_ARGUMENT {
                description "";
            }
            enum OFPTFFC_EPERM {
                description "";
            }
        }
        description
            "ofp_error_msg 'code' values for OFPET_TABLE_FEATURES_FAILED. 'data' contains
 at least the first 64 bytes of the failed request.";
    }
    typedef ofp_multipart_type {
        type enumeration {
            enum OFPMP_DESC {
                description "";
            }
            enum OFPMP_FLOW {
                description "";
            }
            enum OFPMP_AGGREGATE {
                description "";
            }
            enum OFPMP_TABLE {
                description "";
            }
            enum OFPMP_PORT_STATS {
                description "";
            }
            enum OFPMP_QUEUE {
                description "";
            }
            enum OFPMP_GROUP {
                description "";
            }
            enum OFPMP_GROUP_DESC {
                description "";
            }
            enum OFPMP_GROUP_FEATURES {
                description "";
            }
            enum OFPMP_METER {
                description "";
            }
            enum OFPMP_METER_CONFIG {
                description "";
            }
            enum OFPMP_METER_FEATURES {
                description "";
            }
            enum OFPMP_TABLE_FEATURES {
                description "";
            }
            enum OFPMP_PORT_DESC {
                description "";
            }
            enum OFPMP_EXPERIMENTER {
                description "";
            }
        }
        description
            "";
    }
    typedef ofp_multipart_request_flags {
        type enumeration {
            enum OFPMPF_REQ_INVALID {
                description "";
            }
            enum OFPMPF_REQ_MORE {
                description "";
            }
        }
        description
            "Backward compatibility with 1.3.1 - avoid breaking the API.#define ofp_multipart_types ofp_multipart_type";
    }
    typedef ofp_multipart_reply_flags {
        type enumeration {
            enum OFPMPF_REPLY_INVALID {
                description "";
            }
            enum OFPMPF_REPLY_MORE {
                description "";
            }
        }
        description
            "";
    }
    typedef ofp_table_feature_prop_type {
        type enumeration {
            enum OFPTFPT_INSTRUCTIONS {
                description "";
            }
            enum OFPTFPT_INSTRUCTIONS_MISS {
                description "";
            }
            enum OFPTFPT_NEXT_TABLES {
                description "";
            }
            enum OFPTFPT_NEXT_TABLES_MISS {
                description "";
            }
            enum OFPTFPT_WRITE_ACTIONS {
                description "";
            }
            enum OFPTFPT_WRITE_ACTIONS_MISS {
                description "";
            }
            enum OFPTFPT_APPLY_ACTIONS {
                description "";
            }
            enum OFPTFPT_APPLY_ACTIONS_MISS {
                description "";
            }
            enum OFPTFPT_MATCH {
                description "";
            }
            enum OFPTFPT_WILDCARDS {
                description "";
            }
            enum OFPTFPT_WRITE_SETFIELD {
                description "";
            }
            enum OFPTFPT_WRITE_SETFIELD_MISS {
                description "";
            }
            enum OFPTFPT_APPLY_SETFIELD {
                description "";
            }
            enum OFPTFPT_APPLY_SETFIELD_MISS {
                description "";
            }
            enum OFPTFPT_EXPERIMENTER {
                description "";
            }
            enum OFPTFPT_EXPERIMENTER_MISS {
                description "";
            }
        }
        description
            "Table Feature property types.
 Low order bit cleared indicates a property for a regular Flow Entry.
 Low order bit set indicates a property for the Table-Miss Flow Entry.";
    }
    typedef ofp_group_capabilities {
        type enumeration {
            enum OFPGFC_INVALID {
                description "";
            }
            enum OFPGFC_SELECT_WEIGHT {
                description "";
            }
            enum OFPGFC_SELECT_LIVENESS {
                description "";
            }
            enum OFPGFC_CHAINING {
                description "";
            }
            enum OFPGFC_CHAINING_CHECKS {
                description "";
            }
        }
        description
            "Group configuration flagsBackward compatibility with 1.3.1 - avoid breaking the API.#define ofp_group_desc_stats ofp_group_desc";
    }
    typedef ofp_queue_properties {
        type enumeration {
            enum OFPQT_INVALID {
                description "";
            }
            enum OFPQT_MIN_RATE {
                description "";
            }
            enum OFPQT_MAX_RATE {
                description "";
            }
            enum OFPQT_EXPERIMENTER {
                description "";
            }
        }
        description
            "All ones is used to indicate all queues in a port (for stats retrieval).#define OFPQ_ALL      0xffffffff
Min rate   1000 means not configured.#define OFPQ_MIN_RATE_UNCFG      0xffff
Max rate   1000 means not configured.#define OFPQ_MAX_RATE_UNCFG      0xffff";
    }
    typedef ofp_controller_role {
        type enumeration {
            enum OFPCR_ROLE_NOCHANGE {
                description "";
            }
            enum OFPCR_ROLE_EQUAL {
                description "";
            }
            enum OFPCR_ROLE_MASTER {
                description "";
            }
            enum OFPCR_ROLE_SLAVE {
                description "";
            }
        }
        description
            "Controller roles.Configures the  role  of the sending controller.  The default role is:

    - Equal (OFPCR_ROLE_EQUAL), which allows the controller access to all
      OpenFlow features. All controllers have equal responsibility.

 The other possible roles are a related pair:

    - Master (OFPCR_ROLE_MASTER) is equivalent to Equal, except that there
      may be at most one Master controller at a time: when a controller
      configures itself as Master, any existing Master is demoted to the
      Slave role.

    - Slave (OFPCR_ROLE_SLAVE) allows the controller read-only access to
      OpenFlow features.  In particular attempts to modify the flow table
      will be rejected with an OFPBRC_EPERM error.

      Slave controllers do not receive OFPT_PACKET_IN or OFPT_FLOW_REMOVED
      messages, but they do receive OFPT_PORT_STATUS messages.";
    }

    container ofp_header {
        description
            "Header on all OpenFlow packets.";
        leaf version {
            type  uint32;
            description
                "OFP_VERSION.";
        }

        leaf type {
            type  ofp_type;

            description
                "One of the OFPT_ constants.";
        }

        leaf xid {
            type  uint32;
            description
                "Transaction id associated with this packet.
Replies use the same id as was in the request
to facilitate pairing.";
        }



    }

    grouping ofp_hello_elem_header {
        description
            "Common header for all Hello Elements";
        leaf type {
            type  ofp_hello_elem_type;

            description
                "One of OFPHET_ .";
        }



        choice choice_0 {
            case versionbitmap {
                container versionbitmap {
                    uses  ofp_hello_elem_versionbitmap;

                    description
                        "";
                }
            }
        }


    }

    grouping ofp_hello_elem_versionbitmap {
        description
            "Version bitmap Hello Element";
        list bitmaps {
            key "bitmaps";
            leaf bitmaps {
                type  uint32;
                description
                    "List of bitmaps - supported versions";
            }
            description
                "List of bitmaps - supported versions";
        }



    }

    container ofp_hello {
        description
            "OFPT_HELLO.  This message includes zero or more hello elements having
 variable size. Unknown elements types must be ignored skipped, to allow
 for future extensions.ofp_header header;";
        list elements {
            key "type";
            uses  ofp_hello_elem_header;

            description
                "Hello element list0 or more";
        }



    }

    container ofp_switch_config {
        description
            "Switch configuration.";
        leaf flags {
            type  uint32;
            description
                "ofp_header header;
Bitmap of OFPC_  flags.";
        }

        leaf miss_send_len {
            type  uint32;
            description
                "Max bytes of packet that datapath
should send to the controller. See
ofp_controller_max_len for valid values.";
        }



    }

    container ofp_table_mod {
        description
            "Configure Modify behavior of a flow table";
        leaf table_id {
            type  uint32;
            description
                "ofp_header header;
ID of the table, OFPTT_ALL indicates all tables";
        }

        leaf config {
            type  uint32;
            description
                "Bitmap of OFPTC_  flags";
        }



    }

    grouping ofp_port {
        description
            "Description of a port";
        leaf port_no {
            type  uint32;
            description
                "";
        }

        list hw_addr {
            key "hw_addr";
            leaf hw_addr {
                type  uint32;
                description
                    " OFP_ETH_ALEN ;";
            }
            description
                " OFP_ETH_ALEN ;";
        }

        leaf name {
            type  string;
            description
                "Null-terminated";
        }

        leaf config {
            type  uint32;
            description
                "Bitmap of OFPPC_  flags.";
        }

        leaf state {
            type  uint32;
            description
                "Bitmap of OFPPS_  flags.";
        }

        leaf curr {
            type  uint32;
            description
                "Bitmaps of OFPPF_  that describe features.  All bits zeroed if
 unsupported or unavailable.Current features.";
        }

        leaf advertised {
            type  uint32;
            description
                "Features being advertised by the port.";
        }

        leaf supported {
            type  uint32;
            description
                "Features supported by the port.";
        }

        leaf peer {
            type  uint32;
            description
                "Features advertised by peer.";
        }

        leaf curr_speed {
            type  uint32;
            description
                "Current port bitrate in kbps.";
        }

        leaf max_speed {
            type  uint32;
            description
                "Max port bitrate in kbps";
        }



    }

    grouping ofp_switch_features {
        description
            "Switch features.";
        leaf datapath_id {
            type  uint64;
            description
                "ofp_header header;
Datapath unique ID.  The lower 48-bits are for
a MAC address, while the upper 16-bits are
implementer-defined.";
        }

        leaf n_buffers {
            type  uint32;
            description
                "Max packets buffered at once.";
        }

        leaf n_tables {
            type  uint32;
            description
                "Number of tables supported by datapath.";
        }

        leaf auxiliary_id {
            type  uint32;
            description
                "Identify auxiliary connections";
        }

        leaf capabilities {
            type  uint32;
            description
                "Features.Bitmap of support  ofp_capabilities .";
        }



    }

    grouping ofp_port_status {
        description
            "A physical port has changed in the datapath";
        leaf reason {
            type  ofp_port_reason;

            description
                "ofp_header header;
One of OFPPR_ .";
        }

        container desc {
            uses  ofp_port;

            description
                "";
        }



    }

    container ofp_port_mod {
        description
            "Modify behavior of the physical port";
        leaf port_no {
            type  uint32;
            description
                "ofp_header header;";
        }

        list hw_addr {
            key "hw_addr";
            leaf hw_addr {
                type  uint32;
                description
                    " OFP_ETH_ALEN ;";
            }
            description
                " OFP_ETH_ALEN ;";
        }

        leaf config {
            type  uint32;
            description
                "The hardware address is not
configurable.  This is used to
sanity-check the request, so it must
be the same as returned in an
ofp_port struct.Bitmap of OFPPC_  flags.";
        }

        leaf mask {
            type  uint32;
            description
                "Bitmap of OFPPC_  flags to be changed.";
        }

        leaf advertise {
            type  uint32;
            description
                "Bitmap of OFPPF_ .  Zero all bits to prevent
any action taking place.";
        }



    }

    grouping ofp_match {
        description
            "Fields to match against flows";
        leaf type {
            type  ofp_match_type;

            description
                "One of OFPMT_ ";
        }

        list oxm_fields {
            key "oxm_class";
            uses  ofp_oxm_field;

            description
                "0 or more";
        }



    }

    grouping ofp_oxm_field {
        description
            "OXM Flow match fields";
        leaf oxm_class {
            type  ofp_oxm_class;

            description
                "";
        }



        choice choice_0 {
            case ofb_field {
                container ofb_field {
                    uses  ofp_oxm_ofb_field;

                    description
                        "2 and 3 reserved for NXM_0 and NXM-1 OXM classes";
                }
            }
            case experimenter_field {
                container experimenter_field {
                    uses  ofp_oxm_experimenter_field;

                    description
                        "";
                }
            }
        }


    }

    grouping ofp_oxm_ofb_field {
        description
            "OXM OpenFlow Basic Match Field";
        leaf type {
            type  oxm_ofb_field_types;

            description
                "";
        }

        leaf has_mask {
            type  boolean;
            description
                "";
        }



        choice choice_0 {
            case port {
                leaf port {
                    type  uint32;
                    description
                        "#define OXM_OF_IN_PORT    OXM_HEADER  (0x8000, OFPXMT_OFB_IN_PORT, 4)
Used for OFPXMT_OFB_IN_PORTOpenFlow port on which the packet was received.
 May be a physical port, a logical port, or the reserved port OFPP_LOCAL

 Prereqs: None.

 Format: 32-bit integer in network byte order.

 Masking: Not maskable.";
                }
            }
            case physical_port {
                leaf physical_port {
                    type  uint32;
                    description
                        "#define OXM_OF_IN_PHY_PORT OXM_HEADER  (0x8000, OFPXMT_OFB_IN_PHY_PORT, 4)
Used for OFPXMT_OF_IN_PHY_PORTPhysical port on which the packet was received.

 Consider a packet received on a tunnel interface defined over a link
 aggregation group (LAG) with two physical port members.  If the tunnel
 interface is the logical port bound to OpenFlow.  In this case,
 OFPXMT_OF_IN_PORT is the tunnel's port number and OFPXMT_OF_IN_PHY_PORT is
 the physical port number of the LAG on which the tunnel is configured.

 When a packet is received directly on a physical port and not processed by a
 logical port, OFPXMT_OF_IN_PORT and OFPXMT_OF_IN_PHY_PORT have the same
 value.

 This field is usually not available in a regular match and only available
 in ofp_packet_in messages when it's different from OXM_OF_IN_PORT.

 Prereqs: OXM_OF_IN_PORT must be present.

 Format: 32-bit integer in network byte order.

 Masking: Not maskable.";
                }
            }
            case table_metadata {
                leaf table_metadata {
                    type  uint64;
                    description
                        "#define OXM_OF_METADATA   OXM_HEADER  (0x8000, OFPXMT_OFB_METADATA, 8)
#define OXM_OF_METADATA_W OXM_HEADER_W(0x8000, OFPXMT_OFB_METADATA, 8)
Used for OFPXMT_OFB_METADATATable metadata.

 Prereqs: None.

 Format: 64-bit integer in network byte order.

 Masking: Arbitrary masks.";
                }
            }
            case eth_dst {
                leaf eth_dst {
                    type  binary;
                    description
                        "#define OXM_OF_ETH_DST    OXM_HEADER  (0x8000, OFPXMT_OFB_ETH_DST, 6)
#define OXM_OF_ETH_DST_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_ETH_DST, 6)
#define OXM_OF_ETH_SRC    OXM_HEADER  (0x8000, OFPXMT_OFB_ETH_SRC, 6)
#define OXM_OF_ETH_SRC_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_ETH_SRC, 6)
Used for OFPXMT_OFB_ETH_DST (exactly 6 bytes)Source or destination address in Ethernet header.

 Prereqs: None.

 Format: 48-bit Ethernet MAC address.

 Masking: Arbitrary masks.";
                }
            }
            case eth_src {
                leaf eth_src {
                    type  binary;
                    description
                        "Used for OFPXMT_OFB_ETH_SRC (exactly 6 bytes)";
                }
            }
            case eth_type {
                leaf eth_type {
                    type  uint32;
                    description
                        "#define OXM_OF_ETH_TYPE   OXM_HEADER  (0x8000, OFPXMT_OFB_ETH_TYPE,2)
Used for OFPXMT_OFB_ETH_TYPEPacket's Ethernet type.

 Prereqs: None.

 Format: 16-bit integer in network byte order.

 Masking: Not maskable.";
                }
            }
            case vlan_vid {
                leaf vlan_vid {
                    type  uint32;
                    description
                        "#define OXM_OF_VLAN_VID   OXM_HEADER  (0x8000, OFPXMT_OFB_VLAN_VID, 2)
#define OXM_OF_VLAN_VID_W OXM_HEADER_W(0x8000, OFPXMT_OFB_VLAN_VID, 2)
Used for OFPXMT_OFB_VLAN_VID802.1Q VID.

 For a packet with an 802.1Q header, this is the VLAN-ID (VID) from the
 outermost tag, with the CFI bit forced to 1. For a packet with no 802.1Q
 header, this has value OFPVID_NONE.

 Prereqs: None.

 Format: 16-bit integer in network byte order with bit 13 indicating
 presence of VLAN header and 3 most-significant bits forced to 0.
 Only the lower 13 bits have meaning.

 Masking: Arbitrary masks.

 This field can be used in various ways:

   - If it is not constrained at all, the nx_match matches packets without
     an 802.1Q header or with an 802.1Q header that has any VID value.

   - Testing for an exact match with 0x0 matches only packets without
     an 802.1Q header.

   - Testing for an exact match with a VID value with CFI=1 matches packets
     that have an 802.1Q header with a specified VID.

   - Testing for an exact match with a nonzero VID value with CFI=0 does
     not make sense.  The switch may reject this combination.

   - Testing with nxm_value=0, nxm_mask=0x0fff matches packets with no 802.1Q
     header or with an 802.1Q header with a VID of 0.

   - Testing with nxm_value=0x1000, nxm_mask=0x1000 matches packets with
     an 802.1Q header that has any VID value.";
                }
            }
            case vlan_pcp {
                leaf vlan_pcp {
                    type  uint32;
                    description
                        "#define OXM_OF_VLAN_PCP   OXM_HEADER  (0x8000, OFPXMT_OFB_VLAN_PCP, 1)
Used for OFPXMT_OFB_VLAN_PCP802.1Q PCP.

 For a packet with an 802.1Q header, this is the VLAN-PCP from the
 outermost tag.  For a packet with no 802.1Q header, this has value
 0.

 Prereqs: OXM_OF_VLAN_VID must be different from OFPVID_NONE.

 Format: 8-bit integer with 5 most-significant bits forced to 0.
 Only the lower 3 bits have meaning.

 Masking: Not maskable.";
                }
            }
            case ip_dscp {
                leaf ip_dscp {
                    type  uint32;
                    description
                        "#define OXM_OF_IP_DSCP     OXM_HEADER  (0x8000, OFPXMT_OFB_IP_DSCP, 1)
Used for OFPXMT_OFB_IP_DSCPThe Diff Serv Code Point (DSCP) bits of the IP header.
 Part of the IPv4 ToS field or the IPv6 Traffic Class field.

 Prereqs: OXM_OF_ETH_TYPE must be either 0x0800 or 0x86dd.

 Format: 8-bit integer with 2 most-significant bits forced to 0.
 Only the lower 6 bits have meaning.

 Masking: Not maskable.";
                }
            }
            case ip_ecn {
                leaf ip_ecn {
                    type  uint32;
                    description
                        "#define OXM_OF_IP_ECN     OXM_HEADER  (0x8000, OFPXMT_OFB_IP_ECN, 1)
Used for OFPXMT_OFB_IP_ECNThe ECN bits of the IP header.
 Part of the IPv4 ToS field or the IPv6 Traffic Class field.

 Prereqs: OXM_OF_ETH_TYPE must be either 0x0800 or 0x86dd.

 Format: 8-bit integer with 6 most-significant bits forced to 0.
 Only the lower 2 bits have meaning.

 Masking: Not maskable.";
                }
            }
            case ip_proto {
                leaf ip_proto {
                    type  uint32;
                    description
                        "#define OXM_OF_IP_PROTO   OXM_HEADER  (0x8000, OFPXMT_OFB_IP_PROTO, 1)
Used for OFPXMT_OFB_IP_PROTOThe  protocol  byte in the IP header.

 Prereqs: OXM_OF_ETH_TYPE must be either 0x0800 or 0x86dd.

 Format: 8-bit integer.

 Masking: Not maskable.";
                }
            }
            case ipv4_src {
                leaf ipv4_src {
                    type  uint32;
                    description
                        "#define OXM_OF_IPV4_SRC     OXM_HEADER  (0x8000, OFPXMT_OFB_IPV4_SRC, 4)
#define OXM_OF_IPV4_SRC_W   OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV4_SRC, 4)
#define OXM_OF_IPV4_DST     OXM_HEADER  (0x8000, OFPXMT_OFB_IPV4_DST, 4)
#define OXM_OF_IPV4_DST_W   OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV4_DST, 4)
Used for OFPXMT_OFB_IPV4_SRCThe source or destination address in the IP header.

 Prereqs: OXM_OF_ETH_TYPE must match 0x0800 exactly.

 Format: 32-bit integer in network byte order.

 Masking: Arbitrary masks.";
                }
            }
            case ipv4_dst {
                leaf ipv4_dst {
                    type  uint32;
                    description
                        "Used for OFPXMT_OFB_IPV4_DST";
                }
            }
            case tcp_src {
                leaf tcp_src {
                    type  uint32;
                    description
                        "#define OXM_OF_TCP_SRC    OXM_HEADER  (0x8000, OFPXMT_OFB_TCP_SRC, 2)
#define OXM_OF_TCP_DST    OXM_HEADER  (0x8000, OFPXMT_OFB_TCP_DST, 2)
Used for OFPXMT_OFB_TCP_SRCThe source or destination port in the TCP header.

 Prereqs:
   OXM_OF_ETH_TYPE must be either 0x0800 or 0x86dd.
   OXM_OF_IP_PROTO must match 6 exactly.

 Format: 16-bit integer in network byte order.

 Masking: Not maskable.";
                }
            }
            case tcp_dst {
                leaf tcp_dst {
                    type  uint32;
                    description
                        "Used for OFPXMT_OFB_TCP_DST";
                }
            }
            case udp_src {
                leaf udp_src {
                    type  uint32;
                    description
                        "#define OXM_OF_UDP_SRC    OXM_HEADER  (0x8000, OFPXMT_OFB_UDP_SRC, 2)
#define OXM_OF_UDP_DST    OXM_HEADER  (0x8000, OFPXMT_OFB_UDP_DST, 2)
Used for OFPXMT_OFB_UDP_SRCThe source or destination port in the UDP header.

 Prereqs:
   OXM_OF_ETH_TYPE must match either 0x0800 or 0x86dd.
   OXM_OF_IP_PROTO must match 17 exactly.

 Format: 16-bit integer in network byte order.

 Masking: Not maskable.";
                }
            }
            case udp_dst {
                leaf udp_dst {
                    type  uint32;
                    description
                        "Used for OFPXMT_OFB_UDP_DST";
                }
            }
            case sctp_src {
                leaf sctp_src {
                    type  uint32;
                    description
                        "#define OXM_OF_SCTP_SRC   OXM_HEADER  (0x8000, OFPXMT_OFB_SCTP_SRC, 2)
#define OXM_OF_SCTP_DST   OXM_HEADER  (0x8000, OFPXMT_OFB_SCTP_DST, 2)
Used for OFPXMT_OFB_SCTP_SRCThe source or destination port in the SCTP header.

 Prereqs:
   OXM_OF_ETH_TYPE must match either 0x0800 or 0x86dd.
   OXM_OF_IP_PROTO must match 132 exactly.

 Format: 16-bit integer in network byte order.

 Masking: Not maskable.";
                }
            }
            case sctp_dst {
                leaf sctp_dst {
                    type  uint32;
                    description
                        "Used for OFPXMT_OFB_SCTP_DST";
                }
            }
            case icmpv4_type {
                leaf icmpv4_type {
                    type  uint32;
                    description
                        "#define OXM_OF_ICMPV4_TYPE  OXM_HEADER  (0x8000, OFPXMT_OFB_ICMPV4_TYPE, 1)
#define OXM_OF_ICMPV4_CODE  OXM_HEADER  (0x8000, OFPXMT_OFB_ICMPV4_CODE, 1)
Used for OFPXMT_OFB_ICMPV4_TYPEThe type or code in the ICMP header.

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x0800 exactly.
   OXM_OF_IP_PROTO must match 1 exactly.

 Format: 8-bit integer.

 Masking: Not maskable.";
                }
            }
            case icmpv4_code {
                leaf icmpv4_code {
                    type  uint32;
                    description
                        "Used for OFPXMT_OFB_ICMPV4_CODE";
                }
            }
            case arp_op {
                leaf arp_op {
                    type  uint32;
                    description
                        "#define OXM_OF_ARP_OP     OXM_HEADER  (0x8000, OFPXMT_OFB_ARP_OP, 2)
Used for OFPXMT_OFB_ARP_OPARP opcode.

 For an Ethernet+IP ARP packet, the opcode in the ARP header.  Always 0
 otherwise.

 Prereqs: OXM_OF_ETH_TYPE must match 0x0806 exactly.

 Format: 16-bit integer in network byte order.

 Masking: Not maskable.";
                }
            }
            case arp_spa {
                leaf arp_spa {
                    type  uint32;
                    description
                        "#define OXM_OF_ARP_SPA    OXM_HEADER  (0x8000, OFPXMT_OFB_ARP_SPA, 4)
#define OXM_OF_ARP_SPA_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_ARP_SPA, 4)
#define OXM_OF_ARP_TPA    OXM_HEADER  (0x8000, OFPXMT_OFB_ARP_TPA, 4)
#define OXM_OF_ARP_TPA_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_ARP_TPA, 4)
For OFPXMT_OFB_ARP_SPAFor an Ethernet+IP ARP packet, the source or target protocol address
 in the ARP header.  Always 0 otherwise.

 Prereqs: OXM_OF_ETH_TYPE must match 0x0806 exactly.

 Format: 32-bit integer in network byte order.

 Masking: Arbitrary masks.";
                }
            }
            case arp_tpa {
                leaf arp_tpa {
                    type  uint32;
                    description
                        "For OFPXMT_OFB_ARP_TPA";
                }
            }
            case arp_sha {
                leaf arp_sha {
                    type  binary;
                    description
                        "#define OXM_OF_ARP_SHA    OXM_HEADER   (0x8000, OFPXMT_OFB_ARP_SHA, 6)
#define OXM_OF_ARP_SHA_W  OXM_HEADER_W (0x8000, OFPXMT_OFB_ARP_SHA, 6)
#define OXM_OF_ARP_THA    OXM_HEADER   (0x8000, OFPXMT_OFB_ARP_THA, 6)
#define OXM_OF_ARP_THA_W  OXM_HEADER_W (0x8000, OFPXMT_OFB_ARP_THA, 6)
For OFPXMT_OFB_ARP_SHA (6 bytes)For an Ethernet+IP ARP packet, the source or target hardware address
 in the ARP header.  Always 0 otherwise.

 Prereqs: OXM_OF_ETH_TYPE must match 0x0806 exactly.

 Format: 48-bit Ethernet MAC address.

 Masking: Not maskable.";
                }
            }
            case arp_tha {
                leaf arp_tha {
                    type  binary;
                    description
                        "For OFPXMT_OFB_ARP_THA (6 bytes)";
                }
            }
            case ipv6_src {
                leaf ipv6_src {
                    type  binary;
                    description
                        "#define OXM_OF_IPV6_SRC    OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_SRC, 16)
#define OXM_OF_IPV6_SRC_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV6_SRC, 16)
#define OXM_OF_IPV6_DST    OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_DST, 16)
#define OXM_OF_IPV6_DST_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV6_DST, 16)
For OFPXMT_OFB_IPV6_SRCThe source or destination address in the IPv6 header.

 Prereqs: OXM_OF_ETH_TYPE must match 0x86dd exactly.

 Format: 128-bit IPv6 address.

 Masking: Arbitrary masks.";
                }
            }
            case ipv6_dst {
                leaf ipv6_dst {
                    type  binary;
                    description
                        "For OFPXMT_OFB_IPV6_DST";
                }
            }
            case ipv6_flabel {
                leaf ipv6_flabel {
                    type  uint32;
                    description
                        "#define OXM_OF_IPV6_FLABEL   OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_FLABEL, 4)
#define OXM_OF_IPV6_FLABEL_W OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV6_FLABEL, 4)
For OFPXMT_OFB_IPV6_FLABELThe IPv6 Flow Label

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x86dd exactly

 Format: 32-bit integer with 12 most-significant bits forced to 0.
 Only the lower 20 bits have meaning.

 Masking: Arbitrary masks.";
                }
            }
            case icmpv6_type {
                leaf icmpv6_type {
                    type  uint32;
                    description
                        "#define OXM_OF_ICMPV6_TYPE OXM_HEADER  (0x8000, OFPXMT_OFB_ICMPV6_TYPE, 1)
#define OXM_OF_ICMPV6_CODE OXM_HEADER  (0x8000, OFPXMT_OFB_ICMPV6_CODE, 1)
For OFPXMT_OFB_ICMPV6_TYPEThe type or code in the ICMPv6 header.

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x86dd exactly.
   OXM_OF_IP_PROTO must match 58 exactly.

 Format: 8-bit integer.

 Masking: Not maskable.";
                }
            }
            case icmpv6_code {
                leaf icmpv6_code {
                    type  uint32;
                    description
                        "For OFPXMT_OFB_ICMPV6_CODE";
                }
            }
            case ipv6_nd_target {
                leaf ipv6_nd_target {
                    type  binary;
                    description
                        "#define OXM_OF_IPV6_ND_TARGET OXM_HEADER
    (0x8000, OFPXMT_OFB_IPV6_ND_TARGET, 16)
For OFPXMT_OFB_IPV6_ND_TARGETThe target address in an IPv6 Neighbor Discovery message.

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x86dd exactly.
   OXM_OF_IP_PROTO must match 58 exactly.
   OXM_OF_ICMPV6_TYPE must be either 135 or 136.

 Format: 128-bit IPv6 address.

 Masking: Not maskable.";
                }
            }
            case ipv6_nd_ssl {
                leaf ipv6_nd_ssl {
                    type  binary;
                    description
                        "#define OXM_OF_IPV6_ND_SLL  OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_ND_SLL, 6)
For OFPXMT_OFB_IPV6_ND_SLLThe source link-layer address option in an IPv6 Neighbor Discovery
 message.

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x86dd exactly.
   OXM_OF_IP_PROTO must match 58 exactly.
   OXM_OF_ICMPV6_TYPE must be exactly 135.

 Format: 48-bit Ethernet MAC address.

 Masking: Not maskable.";
                }
            }
            case ipv6_nd_tll {
                leaf ipv6_nd_tll {
                    type  binary;
                    description
                        "#define OXM_OF_IPV6_ND_TLL  OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_ND_TLL, 6)
For OFPXMT_OFB_IPV6_ND_TLLThe target link-layer address option in an IPv6 Neighbor Discovery
 message.

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x86dd exactly.
   OXM_OF_IP_PROTO must match 58 exactly.
   OXM_OF_ICMPV6_TYPE must be exactly 136.

 Format: 48-bit Ethernet MAC address.

 Masking: Not maskable.";
                }
            }
            case mpls_label {
                leaf mpls_label {
                    type  uint32;
                    description
                        "#define OXM_OF_MPLS_LABEL  OXM_HEADER  (0x8000, OFPXMT_OFB_MPLS_LABEL, 4)
For OFPXMT_OFB_MPLS_LABELThe LABEL in the first MPLS shim header.

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x8847 or 0x8848 exactly.

 Format: 32-bit integer in network byte order with 12 most-significant
 bits forced to 0. Only the lower 20 bits have meaning.

 Masking: Not maskable.";
                }
            }
            case mpls_tc {
                leaf mpls_tc {
                    type  uint32;
                    description
                        "#define OXM_OF_MPLS_TC     OXM_HEADER  (0x8000, OFPXMT_OFB_MPLS_TC, 1)
For OFPXMT_OFB_MPLS_TCThe TC in the first MPLS shim header.

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x8847 or 0x8848 exactly.

 Format: 8-bit integer with 5 most-significant bits forced to 0.
 Only the lower 3 bits have meaning.

 Masking: Not maskable.";
                }
            }
            case mpls_bos {
                leaf mpls_bos {
                    type  uint32;
                    description
                        "#define OXM_OF_MPLS_BOS     OXM_HEADER  (0x8000, OFPXMT_OFB_MPLS_BOS, 1)
For OFPXMT_OFB_MPLS_BOSThe BoS bit in the first MPLS shim header.

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x8847 or 0x8848 exactly.

 Format: 8-bit integer with 7 most-significant bits forced to 0.
 Only the lowest bit have a meaning.

 Masking: Not maskable.";
                }
            }
            case pbb_isid {
                leaf pbb_isid {
                    type  uint32;
                    description
                        "#define OXM_OF_PBB_ISID   OXM_HEADER  (0x8000, OFPXMT_OFB_PBB_ISID, 3)
#define OXM_OF_PBB_ISID_W OXM_HEADER_W(0x8000, OFPXMT_OFB_PBB_ISID, 3)
For OFPXMT_OFB_PBB_ISIDIEEE 802.1ah I-SID.

 For a packet with a PBB header, this is the I-SID from the
 outermost service tag.

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x88E7 exactly.

 Format: 24-bit integer in network byte order.

 Masking: Arbitrary masks.";
                }
            }
            case tunnel_id {
                leaf tunnel_id {
                    type  uint64;
                    description
                        "#define OXM_OF_TUNNEL_ID    OXM_HEADER  (0x8000, OFPXMT_OFB_TUNNEL_ID, 8)
#define OXM_OF_TUNNEL_ID_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_TUNNEL_ID, 8)
For OFPXMT_OFB_TUNNEL_IDLogical Port Metadata.

 Metadata associated with a logical port.
 If the logical port performs encapsulation and decapsulation, this
 is the demultiplexing field from the encapsulation header.
 For example, for a packet received via GRE tunnel including a (32-bit) key,
 the key is stored in the low 32-bits and the high bits are zeroed.
 For a MPLS logical port, the low 20 bits represent the MPLS Label.
 For a VxLAN logical port, the low 24 bits represent the VNI.
 If the packet is not received through a logical port, the value is 0.

 Prereqs: None.

 Format: 64-bit integer in network byte order.

 Masking: Arbitrary masks.";
                }
            }
            case ipv6_exthdr {
                leaf ipv6_exthdr {
                    type  uint32;
                    description
                        "#define OXM_OF_IPV6_EXTHDR   OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_EXTHDR, 2)
#define OXM_OF_IPV6_EXTHDR_W OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV6_EXTHDR, 2)
For OFPXMT_OFB_IPV6_EXTHDRThe IPv6 Extension Header pseudo-field.

 Prereqs:
   OXM_OF_ETH_TYPE must match 0x86dd exactly

 Format: 16-bit integer with 7 most-significant bits forced to 0.
 Only the lower 9 bits have meaning.

 Masking: Maskable.";
                }
            }
        }
        choice choice_1 {
            case table_metadata_mask {
                leaf table_metadata_mask {
                    type  uint64;
                    description
                        "For OFPXMT_OFB_METADATA";
                }
            }
            case eth_dst_mask {
                leaf eth_dst_mask {
                    type  binary;
                    description
                        "For OFPXMT_OFB_ETH_DST (exactly 6 bytes)";
                }
            }
            case eth_src_mask {
                leaf eth_src_mask {
                    type  binary;
                    description
                        "For OFPXMT_OFB_ETH_SRC (exactly 6 bytes)";
                }
            }
            case vlan_vid_mask {
                leaf vlan_vid_mask {
                    type  uint32;
                    description
                        "For OFPXMT_OFB_VLAN_VID";
                }
            }
            case ipv4_src_mask {
                leaf ipv4_src_mask {
                    type  uint32;
                    description
                        "For OFPXMT_OFB_IPV4_SRC";
                }
            }
            case ipv4_dst_mask {
                leaf ipv4_dst_mask {
                    type  uint32;
                    description
                        "For OFPXMT_OFB_IPV4_DST";
                }
            }
            case arp_spa_mask {
                leaf arp_spa_mask {
                    type  uint32;
                    description
                        "For OFPXMT_OFB_ARP_SPA";
                }
            }
            case arp_tpa_mask {
                leaf arp_tpa_mask {
                    type  uint32;
                    description
                        "For OFPXMT_OFB_ARP_TPA";
                }
            }
            case ipv6_src_mask {
                leaf ipv6_src_mask {
                    type  binary;
                    description
                        "For OFPXMT_OFB_IPV6_SRC";
                }
            }
            case ipv6_dst_mask {
                leaf ipv6_dst_mask {
                    type  binary;
                    description
                        "For OFPXMT_OFB_IPV6_DST";
                }
            }
            case ipv6_flabel_mask {
                leaf ipv6_flabel_mask {
                    type  uint32;
                    description
                        "For OFPXMT_OFB_IPV6_FLABEL";
                }
            }
            case pbb_isid_mask {
                leaf pbb_isid_mask {
                    type  uint32;
                    description
                        "For OFPXMT_OFB_PBB_ISID";
                }
            }
            case tunnel_id_mask {
                leaf tunnel_id_mask {
                    type  uint64;
                    description
                        "For OFPXMT_OFB_TUNNEL_ID";
                }
            }
            case ipv6_exthdr_mask {
                leaf ipv6_exthdr_mask {
                    type  uint32;
                    description
                        "For OFPXMT_OFB_IPV6_EXTHDR";
                }
            }
        }


    }

    grouping ofp_oxm_experimenter_field {
        description
            "Header for OXM experimenter match fields.
 The experimenter class should not use OXM_HEADER() macros for defining
 fields due to this extra header.";
        leaf oxm_header {
            type  uint32;
            description
                "oxm_class = OFPXMC_EXPERIMENTER";
        }

        leaf experimenter {
            type  uint32;
            description
                "Experimenter ID which takes the same
form as in struct ofp_experimenter_header.";
        }



    }

    grouping ofp_action {
        description
            "Action header that is common to all actions.  The length includes the
 header and any padding used to make the action 64-bit aligned.
 NB: The length of an action  must  always be a multiple of eight.";
        leaf type {
            type  ofp_action_type;

            description
                "One of OFPAT_ .";
        }



        choice choice_0 {
            case output {
                container output {
                    uses  ofp_action_output;

                    description
                        "";
                }
            }
            case mpls_ttl {
                container mpls_ttl {
                    uses  ofp_action_mpls_ttl;

                    description
                        "";
                }
            }
            case push {
                container push {
                    uses  ofp_action_push;

                    description
                        "";
                }
            }
            case pop_mpls {
                container pop_mpls {
                    uses  ofp_action_pop_mpls;

                    description
                        "";
                }
            }
            case group {
                container group {
                    uses  ofp_action_group;

                    description
                        "";
                }
            }
            case nw_ttl {
                container nw_ttl {
                    uses  ofp_action_nw_ttl;

                    description
                        "";
                }
            }
            case set_field {
                container set_field {
                    uses  ofp_action_set_field;
f
                    description
                        "";
                }
            }
            case experimenter {
                container experimenter {
                    uses  ofp_action_experimenter;

                    description
                        "";
                }
            }
        }


    }

    grouping ofp_action_output {
        description
            "Action structure for OFPAT_OUTPUT, which sends packets out 'port'.
 When the 'port' is the OFPP_CONTROLLER, 'max_len' indicates the max
 number of bytes to send.  A 'max_len' of zero means no bytes of the
 packet should be sent. A 'max_len' of OFPCML_NO_BUFFER means that
 the packet is not buffered and the complete packet is to be sent to
 the controller.";
        leaf port {
            type  uint32;
            description
                "Output port.";
        }

        leaf max_len {
            type  uint32;
            description
                "Max length to send to controller.";
        }



    }

    grouping ofp_action_mpls_ttl {
        description
            "Action structure for OFPAT_SET_MPLS_TTL.";
        leaf mpls_ttl {
            type  uint32;
            description
                "MPLS TTL";
        }



    }

    grouping ofp_action_push {
        description
            "Action structure for OFPAT_PUSH_VLAN MPLS PBB.";
        leaf ethertype {
            type  uint32;
            description
                "Ethertype";
        }



    }

    grouping ofp_action_pop_mpls {
        description
            "Action structure for OFPAT_POP_MPLS.";
        leaf ethertype {
            type  uint32;
            description
                "Ethertype";
        }



    }

    grouping ofp_action_group {
        description
            "Action structure for OFPAT_GROUP.";
        leaf group_id {
            type  uint32;
            description
                "Group identifier.";
        }



    }

    grouping ofp_action_nw_ttl {
        description
            "Action structure for OFPAT_SET_NW_TTL.";
        leaf nw_ttl {
            type  uint32;
            description
                "IP TTL";
        }



    }

    grouping ofp_action_set_field {
        description
            "Action structure for OFPAT_SET_FIELD.";
        container field {
            uses  ofp_oxm_field;

            description
                "";
        }



    }

    grouping ofp_action_experimenter {
        description
            "Action header for OFPAT_EXPERIMENTER.
 The rest of the body is experimenter-defined.";
        leaf experimenter {
            type  uint32;
            description
                "Experimenter ID which takes the same
form as in struct
ofp_experimenter_header.";
        }

        leaf data {
            type  binary;
            description
                "";
        }



    }

    grouping ofp_instruction {
        description
            "Instruction header that is common to all instructions.  The length includes
 the header and any padding used to make the instruction 64-bit aligned.
 NB: The length of an instruction  must  always be a multiple of eight.";
        leaf type {
            type  uint32;
            description
                "Instruction type";
        }



        choice choice_0 {
            case goto_table {
                container goto_table {
                    uses  ofp_instruction_goto_table;

                    description
                        "";
                }
            }
            case write_metadata {
                container write_metadata {
                    uses  ofp_instruction_write_metadata;

                    description
                        "";
                }
            }
            case actions {
                container actions {
                    uses  ofp_instruction_actions;

                    description
                        "";
                }
            }
            case meter {
                container meter {
                    uses  ofp_instruction_meter;

                    description
                        "";
                }
            }
            case experimenter {
                container experimenter {
                    uses  ofp_instruction_experimenter;

                    description
                        "";
                }
            }
        }


    }

    grouping ofp_instruction_goto_table {
        description
            "Instruction structure for OFPIT_GOTO_TABLE";
        leaf table_id {
            type  uint32;
            description
                "Set next table in the lookup pipeline";
        }



    }

    grouping ofp_instruction_write_metadata {
        description
            "Instruction structure for OFPIT_WRITE_METADATA";
        leaf metadata {
            type  uint64;
            description
                "Metadata value to write";
        }

        leaf metadata_mask {
            type  uint64;
            description
                "Metadata write bitmask";
        }



    }

    grouping ofp_instruction_actions {
        description
            "Instruction structure for OFPIT_WRITE APPLY CLEAR_ACTIONS";
        list actions {
            key "type";
            uses  ofp_action;

            description
                "0 or more actions associated
with OFPIT_WRITE_ACTIONS and
OFPIT_APPLY_ACTIONS";
        }



    }

    grouping ofp_instruction_meter {
        description
            "Instruction structure for OFPIT_METER";
        leaf meter_id {
            type  uint32;
            description
                "Meter instance.";
        }



    }

    grouping ofp_instruction_experimenter {
        description
            "Instruction structure for experimental instructions";
        leaf experimenter {
            type  uint32;
            description
                "Experimenter ID which takes the same form
as in struct ofp_experimenter_header.";
        }

        leaf data {
            type  binary;
            description
                "Experimenter-defined arbitrary additional data.";
        }



    }

    grouping ofp_flow_mod {
        description
            "Flow setup and teardown (controller -  datapath).";
        leaf cookie {
            type  uint64;
            description
                "ofp_header header;
Opaque controller-issued identifier.";
        }

        leaf cookie_mask {
            type  uint64;
            description
                "Mask used to restrict the cookie bits
that must match when the command is
OFPFC_MODIFY  or OFPFC_DELETE . A value
of 0 indicates no restriction.";
        }

        leaf table_id {
            type  uint32;
            description
                "ID of the table to put the flow in.
For OFPFC_DELETE_  commands, OFPTT_ALL
can also be used to delete matching
flows from all tables.";
        }

        leaf command {
            type  ofp_flow_mod_command;

            description
                "One of OFPFC_ .";
        }

        leaf idle_timeout {
            type  uint32;
            description
                "Idle time before discarding (seconds).";
        }

        leaf hard_timeout {
            type  uint32;
            description
                "Max time before discarding (seconds).";
        }

        leaf priority {
            type  uint32;
            description
                "Priority level of flow entry.";
        }

        leaf buffer_id {
            type  uint32;
            description
                "Buffered packet to apply to, or
OFP_NO_BUFFER.
Not meaningful for OFPFC_DELETE .";
        }

        leaf out_port {
            type  uint32;
            description
                "For OFPFC_DELETE  commands, require
matching entries to include this as an
output port.  A value of OFPP_ANY
indicates no restriction.";
        }

        leaf out_group {
            type  uint32;
            description
                "For OFPFC_DELETE  commands, require
matching entries to include this as an
output group.  A value of OFPG_ANY
indicates no restriction.";
        }

        leaf flags {
            type  uint32;
            description
                "Bitmap of OFPFF_  flags.";
        }

        container match {
            uses  ofp_match;

            description
                "Fields to match. Variable size.";
        }

        list instructions {
            key "type";
            uses  ofp_instruction;

            description
                "0 or more.";
        }



    }

    grouping ofp_bucket {
        description
            "Bucket for use in groups.";
        leaf weight {
            type  uint32;
            description
                "Relative weight of bucket.  Only
defined for select groups.";
        }

        leaf watch_port {
            type  uint32;
            description
                "Port whose state affects whether this
bucket is live.  Only required for fast
failover groups.";
        }

        leaf watch_group {
            type  uint32;
            description
                "Group whose state affects whether this
bucket is live.  Only required for fast
failover groups.";
        }

        list actions {
            key "type";
            uses  ofp_action;

            description
                "";
        }



    }

    grouping ofp_group_mod {
        description
            "Group setup and teardown (controller -  datapath).";
        leaf command {
            type  ofp_group_mod_command;

            description
                "ofp_header header;
One of OFPGC_ .";
        }

        leaf type {
            type  ofp_group_type;

            description
                "One of OFPGT_ .";
        }

        leaf group_id {
            type  uint32;
            description
                "Group identifier.";
        }

        list buckets {
            key "weight";
            uses  ofp_bucket;

            description
                "";
        }



    }

    grouping ofp_packet_out {
        description
            "Send packet (controller -  datapath).Special buffer-id to indicate 'no buffer'#define OFP_NO_BUFFER 0xffffffff";
        leaf buffer_id {
            type  uint32;
            description
                "ofp_header header;
ID assigned by datapath (OFP_NO_BUFFER
if none).";
        }

        leaf in_port {
            type  uint32;
            description
                "Packet's input port or OFPP_CONTROLLER.";
        }

        list actions {
            key "type";
            uses  ofp_action;

            description
                "Action list - 0 or more.";
        }

        leaf data {
            type  binary;
            description
                "The variable size action list is optionally followed by packet data.
 This data is only present and meaningful if buffer_id == -1.Packet data.";
        }



    }

    grouping ofp_packet_in {
        description
            "Packet received on port (datapath -  controller).";
        leaf buffer_id {
            type  uint32;
            description
                "ofp_header header;
ID assigned by datapath.";
        }

        leaf reason {
            type  ofp_packet_in_reason;

            description
                "Reason packet is being sent";
        }

        leaf table_id {
            type  uint32;
            description
                "ID of the table that was looked up";
        }

        leaf cookie {
            type  uint64;
            description
                "Cookie of the flow entry that was looked up.";
        }

        container match {
            uses  ofp_match;

            description
                "Packet metadata. Variable size.";
        }

        leaf data {
            type  binary;
            description
                "Ethernet frame";
        }



    }

    container ofp_flow_removed {
        description
            "Flow removed (datapath -  controller).";
        leaf cookie {
            type  uint64;
            description
                "ofp_header header;
Opaque controller-issued identifier.";
        }

        leaf priority {
            type  uint32;
            description
                "Priority level of flow entry.";
        }

        leaf reason {
            type  ofp_flow_removed_reason;

            description
                "One of OFPRR_ .";
        }

        leaf table_id {
            type  uint32;
            description
                "ID of the table";
        }

        leaf duration_sec {
            type  uint32;
            description
                "Time flow was alive in seconds.";
        }

        leaf duration_nsec {
            type  uint32;
            description
                "Time flow was alive in nanoseconds beyond
duration_sec.";
        }

        leaf idle_timeout {
            type  uint32;
            description
                "Idle timeout from original flow mod.";
        }

        leaf hard_timeout {
            type  uint32;
            description
                "Hard timeout from original flow mod.";
        }

        leaf packet_count {
            type  uint64;
            description
                "";
        }

        leaf byte_count {
            type  uint64;
            description
                "";
        }

        container match {
            uses  ofp_match;

            description
                "Description of fields. Variable size.";
        }



    }

    grouping ofp_meter_band_header {
        description
            "Common header for all meter bands";
        leaf type {
            type  ofp_meter_band_type;

            description
                "One of OFPMBT_ .";
        }

        leaf len {
            type  uint32;
            description
                "Length in bytes of this band.";
        }

        leaf rate {
            type  uint32;
            description
                "Rate for this band.";
        }

        leaf burst_size {
            type  uint32;
            description
                "Size of bursts.";
        }



    }

    container ofp_meter_band_drop {
        description
            "OFPMBT_DROP band - drop packets";
        leaf type {
            type  uint32;
            description
                "OFPMBT_DROP.";
        }

        leaf len {
            type  uint32;
            description
                "Length in bytes of this band.";
        }

        leaf rate {
            type  uint32;
            description
                "Rate for dropping packets.";
        }

        leaf burst_size {
            type  uint32;
            description
                "Size of bursts.";
        }



    }

    container ofp_meter_band_dscp_remark {
        description
            "OFPMBT_DSCP_REMARK band - Remark DSCP in the IP header";
        leaf type {
            type  uint32;
            description
                "OFPMBT_DSCP_REMARK.";
        }

        leaf len {
            type  uint32;
            description
                "Length in bytes of this band.";
        }

        leaf rate {
            type  uint32;
            description
                "Rate for remarking packets.";
        }

        leaf burst_size {
            type  uint32;
            description
                "Size of bursts.";
        }

        leaf prec_level {
            type  uint32;
            description
                "Number of drop precedence level to add.";
        }



    }

    container ofp_meter_band_experimenter {
        description
            "OFPMBT_EXPERIMENTER band - Experimenter type.
 The rest of the band is experimenter-defined.";
        leaf type {
            type  ofp_meter_band_type;

            description
                "One of OFPMBT_ .";
        }

        leaf len {
            type  uint32;
            description
                "Length in bytes of this band.";
        }

        leaf rate {
            type  uint32;
            description
                "Rate for this band.";
        }

        leaf burst_size {
            type  uint32;
            description
                "Size of bursts.";
        }

        leaf experimenter {
            type  uint32;
            description
                "Experimenter ID which takes the
same form as in struct
ofp_experimenter_header.";
        }



    }

    container ofp_meter_mod {
        description
            "Meter configuration. OFPT_METER_MOD.";
        leaf command {
            type  ofp_meter_mod_command;

            description
                "ofp_header   header = 1;
One of OFPMC_ .";
        }

        leaf flags {
            type  uint32;
            description
                "Bitmap of OFPMF_  flags.";
        }

        leaf meter_id {
            type  uint32;
            description
                "Meter instance.";
        }

        list bands {
            key "type";
            uses  ofp_meter_band_header;

            description
                "The band list length is
inferred from the length field
in the header.";
        }



    }

    container ofp_error_msg {
        description
            "OFPT_ERROR: Error message (datapath -  controller).";
        leaf type {
            type  uint32;
            description
                "ofp_header header;";
        }

        leaf code {
            type  uint32;
            description
                "";
        }

        leaf data {
            type  binary;
            description
                "Variable-length data.  Interpreted based
on the type and code.  No padding.";
        }



    }

    container ofp_error_experimenter_msg {
        description
            "OFPET_EXPERIMENTER: Error message (datapath -  controller).ofp_header header;";
        leaf type {
            type  uint32;
            description
                "OFPET_EXPERIMENTER.";
        }

        leaf exp_type {
            type  uint32;
            description
                "Experimenter defined.";
        }

        leaf experimenter {
            type  uint32;
            description
                "Experimenter ID which takes the same form
as in struct ofp_experimenter_header.";
        }

        leaf data {
            type  binary;
            description
                "Variable-length data.  Interpreted based
on the type and code.  No padding.";
        }



    }

    container ofp_multipart_request {
        description
            "";
        leaf type {
            type  ofp_multipart_type;

            description
                "ofp_header header;
One of the OFPMP_  constants.";
        }

        leaf flags {
            type  uint32;
            description
                "OFPMPF_REQ_  flags.";
        }

        leaf body {
            type  binary;
            description
                "Body of the request. 0 or more bytes.";
        }



    }

    container ofp_multipart_reply {
        description
            "";
        leaf type {
            type  ofp_multipart_type;

            description
                "ofp_header header;
One of the OFPMP_  constants.";
        }

        leaf flags {
            type  uint32;
            description
                "OFPMPF_REPLY_  flags.";
        }

        leaf body {
            type  binary;
            description
                "Body of the reply. 0 or more bytes.";
        }



    }

    grouping ofp_desc {
        description
            "Body of reply to OFPMP_DESC request.  Each entry is a NULL-terminated
 ASCII string.#define DESC_STR_LEN   256
#define SERIAL_NUM_LEN 32";
        leaf mfr_desc {
            type  string;
            description
                "Manufacturer description.";
        }

        leaf hw_desc {
            type  string;
            description
                "Hardware description.";
        }

        leaf sw_desc {
            type  string;
            description
                "Software description.";
        }

        leaf serial_num {
            type  string;
            description
                "Serial number.";
        }

        leaf dp_desc {
            type  string;
            description
                "Human readable description of datapath.";
        }



    }

    container ofp_flow_stats_request {
        description
            "Body for ofp_multipart_request of type OFPMP_FLOW.";
        leaf table_id {
            type  uint32;
            description
                "ID of table to read (from ofp_table_stats),
OFPTT_ALL for all tables.";
        }

        leaf out_port {
            type  uint32;
            description
                "Require matching entries to include this
as an output port.  A value of OFPP_ANY
indicates no restriction.";
        }

        leaf out_group {
            type  uint32;
            description
                "Require matching entries to include this
as an output group.  A value of OFPG_ANY
indicates no restriction.";
        }

        leaf cookie {
            type  uint64;
            description
                "Require matching entries to contain this
cookie value";
        }

        leaf cookie_mask {
            type  uint64;
            description
                "Mask used to restrict the cookie bits that
must match. A value of 0 indicates
no restriction.";
        }

        container match {
            uses  ofp_match;

            description
                "Fields to match. Variable size.";
        }



    }

    grouping ofp_flow_stats {
        description
            "Body of reply to OFPMP_FLOW request.";
        leaf id {
            type  uint64;
            description
                "Unique ID of flow within device.";
        }

        leaf table_id {
            type  uint32;
            description
                "ID of table flow came from.";
        }

        leaf duration_sec {
            type  uint32;
            description
                "Time flow has been alive in seconds.";
        }

        leaf duration_nsec {
            type  uint32;
            description
                "Time flow has been alive in nanoseconds
beyond duration_sec.";
        }

        leaf priority {
            type  uint32;
            description
                "Priority of the entry.";
        }

        leaf idle_timeout {
            type  uint32;
            description
                "Number of seconds idle before expiration.";
        }

        leaf hard_timeout {
            type  uint32;
            description
                "Number of seconds before expiration.";
        }

        leaf flags {
            type  uint32;
            description
                "Bitmap of OFPFF_  flags.";
        }

        leaf cookie {
            type  uint64;
            description
                "Opaque controller-issued identifier.";
        }

        leaf packet_count {
            type  uint64;
            description
                "Number of packets in flow.";
        }

        leaf byte_count {
            type  uint64;
            description
                "Number of bytes in flow.";
        }

        container match {
            uses  ofp_match;

            description
                "Description of fields. Variable size.";
        }

        list instructions {
            key "type";
            uses  ofp_instruction;

            description
                "Instruction set
(0 or more)";
        }



    }

    container ofp_aggregate_stats_request {
        description
            "Body for ofp_multipart_request of type OFPMP_AGGREGATE.";
        leaf table_id {
            type  uint32;
            description
                "ID of table to read (from ofp_table_stats)
OFPTT_ALL for all tables.";
        }

        leaf out_port {
            type  uint32;
            description
                "Require matching entries to include this
as an output port.  A value of OFPP_ANY
indicates no restriction.";
        }

        leaf out_group {
            type  uint32;
            description
                "Require matching entries to include this
as an output group.  A value of OFPG_ANY
indicates no restriction.";
        }

        leaf cookie {
            type  uint64;
            description
                "Require matching entries to contain this
cookie value";
        }

        leaf cookie_mask {
            type  uint64;
            description
                "Mask used to restrict the cookie bits that
must match. A value of 0 indicates
no restriction.";
        }

        container match {
            uses  ofp_match;

            description
                "Fields to match. Variable size.";
        }



    }

    container ofp_aggregate_stats_reply {
        description
            "Body of reply to OFPMP_AGGREGATE request.";
        leaf packet_count {
            type  uint64;
            description
                "Number of packets in flows.";
        }

        leaf byte_count {
            type  uint64;
            description
                "Number of bytes in flows.";
        }

        leaf flow_count {
            type  uint32;
            description
                "Number of flows.";
        }



    }

    grouping ofp_table_feature_property {
        description
            "Common header for all Table Feature Properties";
        leaf type {
            type  ofp_table_feature_prop_type;

            description
                "One of OFPTFPT_ .";
        }



        choice choice_0 {
            case instructions {
                container instructions {
                    uses  ofp_table_feature_prop_instructions;

                    description
                        "";
                }
            }
            case next_tables {
                container next_tables {
                    uses  ofp_table_feature_prop_next_tables;

                    description
                        "";
                }
            }
            case actions {
                container actions {
                    uses  ofp_table_feature_prop_actions;

                    description
                        "";
                }
            }
            case oxm {
                container oxm {
                    uses  ofp_table_feature_prop_oxm;

                    description
                        "";
                }
            }
            case experimenter {
                container experimenter {
                    uses  ofp_table_feature_prop_experimenter;

                    description
                        "";
                }
            }
        }


    }

    grouping ofp_table_feature_prop_instructions {
        description
            "Instructions property";
        list instructions {
            key "type";
            uses  ofp_instruction;

            description
                "One of OFPTFPT_INSTRUCTIONS,
OFPTFPT_INSTRUCTIONS_MISS.List of instructions";
        }



    }

    grouping ofp_table_feature_prop_next_tables {
        description
            "Next Tables property";
        list next_table_ids {
            key "next_table_ids";
            leaf next_table_ids {
                type  uint32;
                description
                    "One of OFPTFPT_NEXT_TABLES,
OFPTFPT_NEXT_TABLES_MISS.List of table ids.";
            }
            description
                "One of OFPTFPT_NEXT_TABLES,
OFPTFPT_NEXT_TABLES_MISS.List of table ids.";
        }



    }

    grouping ofp_table_feature_prop_actions {
        description
            "Actions property";
        list actions {
            key "type";
            uses  ofp_action;

            description
                "One of OFPTFPT_WRITE_ACTIONS,
OFPTFPT_WRITE_ACTIONS_MISS,
OFPTFPT_APPLY_ACTIONS,
OFPTFPT_APPLY_ACTIONS_MISS.List of actions";
        }



    }

    grouping ofp_table_feature_prop_oxm {
        description
            "Match, Wildcard or Set-Field propertyOne of OFPTFPT_MATCH,
OFPTFPT_WILDCARDS,
OFPTFPT_WRITE_SETFIELD,
OFPTFPT_WRITE_SETFIELD_MISS,
OFPTFPT_APPLY_SETFIELD,
OFPTFPT_APPLY_SETFIELD_MISS.";
        list oxm_ids {
            key "oxm_ids";
            leaf oxm_ids {
                type  uint32;
                description
                    "TODO is this a uint32???Array of OXM headers";
            }
            description
                "TODO is this a uint32???Array of OXM headers";
        }



    }

    grouping ofp_table_feature_prop_experimenter {
        description
            "Experimenter table feature property";
        leaf experimenter {
            type  uint32;
            description
                "One of OFPTFPT_EXPERIMENTER,
OFPTFPT_EXPERIMENTER_MISS.Experimenter ID which takes the same
form as in struct
ofp_experimenter_header.";
        }

        leaf exp_type {
            type  uint32;
            description
                "Experimenter defined.";
        }

        list experimenter_data {
            key "experimenter_data";
            leaf experimenter_data {
                type  uint32;
                description
                    "";
            }
            description
                "";
        }



    }

    container ofp_table_features {
        description
            "Body for ofp_multipart_request of type OFPMP_TABLE_FEATURES.
 Body of reply to OFPMP_TABLE_FEATURES request.";
        leaf table_id {
            type  uint32;
            description
                "Identifier of table.  Lower numbered tables
are consulted first.";
        }

        leaf name {
            type  string;
            description
                "";
        }

        leaf metadata_match {
            type  uint64;
            description
                "Bits of metadata table can match.";
        }

        leaf metadata_write {
            type  uint64;
            description
                "Bits of metadata table can write.";
        }

        leaf config {
            type  uint32;
            description
                "Bitmap of OFPTC_  values";
        }

        leaf max_entries {
            type  uint32;
            description
                "Max number of entries supported.";
        }

        list properties {
            key "type";
            uses  ofp_table_feature_property;

            description
                "Table Feature Property list";
        }



    }

    container ofp_table_stats {
        description
            "Body of reply to OFPMP_TABLE request.";
        leaf table_id {
            type  uint32;
            description
                "Identifier of table.  Lower numbered tables
are consulted first.";
        }

        leaf active_count {
            type  uint32;
            description
                "Number of active entries.";
        }

        leaf lookup_count {
            type  uint64;
            description
                "Number of packets looked up in table.";
        }

        leaf matched_count {
            type  uint64;
            description
                "Number of packets that hit table.";
        }



    }

    container ofp_port_stats_request {
        description
            "Body for ofp_multipart_request of type OFPMP_PORT.";
        leaf port_no {
            type  uint32;
            description
                "OFPMP_PORT message must request statistics
 either for a single port (specified in
 port_no) or for all ports (if port_no ==
 OFPP_ANY).";
        }



    }

    container ofp_port_stats {
        description
            "Body of reply to OFPMP_PORT request. If a counter is unsupported, set
 the field to all ones.";
        leaf port_no {
            type  uint32;
            description
                "";
        }

        leaf rx_packets {
            type  uint64;
            description
                "Number of received packets.";
        }

        leaf tx_packets {
            type  uint64;
            description
                "Number of transmitted packets.";
        }

        leaf rx_bytes {
            type  uint64;
            description
                "Number of received bytes.";
        }

        leaf tx_bytes {
            type  uint64;
            description
                "Number of transmitted bytes.";
        }

        leaf rx_dropped {
            type  uint64;
            description
                "Number of packets dropped by RX.";
        }

        leaf tx_dropped {
            type  uint64;
            description
                "Number of packets dropped by TX.";
        }

        leaf rx_errors {
            type  uint64;
            description
                "Number of receive errors.  This is a super-set
of more specific receive errors and should be
greater than or equal to the sum of all
rx_ _err values.";
        }

        leaf tx_errors {
            type  uint64;
            description
                "Number of transmit errors.  This is a super-set
of more specific transmit errors and should be
greater than or equal to the sum of all
tx_ _err values (none currently defined.)";
        }

        leaf rx_frame_err {
            type  uint64;
            description
                "Number of frame alignment errors.";
        }

        leaf rx_over_err {
            type  uint64;
            description
                "Number of packets with RX overrun.";
        }

        leaf rx_crc_err {
            type  uint64;
            description
                "Number of CRC errors.";
        }

        leaf collisions {
            type  uint64;
            description
                "Number of collisions.";
        }

        leaf duration_sec {
            type  uint32;
            description
                "Time port has been alive in seconds.";
        }

        leaf duration_nsec {
            type  uint32;
            description
                "Time port has been alive in nanoseconds
beyond duration_sec.";
        }



    }

    container ofp_group_stats_request {
        description
            "Body of OFPMP_GROUP request.";
        leaf group_id {
            type  uint32;
            description
                "All groups if OFPG_ALL.";
        }



    }

    grouping ofp_bucket_counter {
        description
            "Used in group stats replies.";
        leaf packet_count {
            type  uint64;
            description
                "Number of packets processed by bucket.";
        }

        leaf byte_count {
            type  uint64;
            description
                "Number of bytes processed by bucket.";
        }



    }

    grouping ofp_group_stats {
        description
            "Body of reply to OFPMP_GROUP request.";
        leaf group_id {
            type  uint32;
            description
                "Group identifier.";
        }

        leaf ref_count {
            type  uint32;
            description
                "Number of flows or groups that directly
forward to this group.";
        }

        leaf packet_count {
            type  uint64;
            description
                "Number of packets processed by group.";
        }

        leaf byte_count {
            type  uint64;
            description
                "Number of bytes processed by group.";
        }

        leaf duration_sec {
            type  uint32;
            description
                "Time group has been alive in seconds.";
        }

        leaf duration_nsec {
            type  uint32;
            description
                "Time group has been alive in nanoseconds
beyond duration_sec.";
        }

        list bucket_stats {
            key "packet_count";
            uses  ofp_bucket_counter;

            description
                "One counter set per
bucket.";
        }



    }

    grouping ofp_group_desc {
        description
            "Body of reply to OFPMP_GROUP_DESC request.";
        leaf type {
            type  ofp_group_type;

            description
                "One of OFPGT_ .";
        }

        leaf group_id {
            type  uint32;
            description
                "Group identifier.";
        }

        list buckets {
            key "weight";
            uses  ofp_bucket;

            description
                "List of buckets - 0 or more.";
        }



    }

    grouping ofp_group_entry {
        description
            "";
        leaf type {
            type  ofp_group_type;

            description
                "One of OFPGT_ .";
        }

        leaf group_id {
            type  uint32;
            description
                "Group identifier.";
        }

        list buckets {
            key "weight";
            uses  ofp_bucket;

            description
                "List of buckets - 0 or more.";
        }

        container stats {
            uses  ofp_group_stats;

            description
                "";
        }



    }

    container ofp_group_features {
        description
            "Body of reply to OFPMP_GROUP_FEATURES request. Group features.";
        leaf types {
            type  uint32;
            description
                "Bitmap of (1    OFPGT_ ) values supported.";
        }

        leaf capabilities {
            type  uint32;
            description
                "Bitmap of OFPGFC_  capability supported.";
        }

        list max_groups {
            key "max_groups";
            leaf max_groups {
                type  uint32;
                description
                    "Maximum number of groups for each type.";
            }
            description
                "Maximum number of groups for each type.";
        }

        list actions {
            key "actions";
            leaf actions {
                type  uint32;
                description
                    "Bitmaps of (1    OFPAT_ ) values
supported.";
            }
            description
                "Bitmaps of (1    OFPAT_ ) values
supported.";
        }



    }

    container ofp_meter_multipart_request {
        description
            "Body of OFPMP_METER and OFPMP_METER_CONFIG requests.";
        leaf meter_id {
            type  uint32;
            description
                "Meter instance, or OFPM_ALL.";
        }



    }

    grouping ofp_meter_band_stats {
        description
            "Statistics for each meter band";
        leaf packet_band_count {
            type  uint64;
            description
                "Number of packets in band.";
        }

        leaf byte_band_count {
            type  uint64;
            description
                "Number of bytes in band.";
        }



    }

    container ofp_meter_stats {
        description
            "Body of reply to OFPMP_METER request. Meter statistics.";
        leaf meter_id {
            type  uint32;
            description
                "Meter instance.";
        }

        leaf flow_count {
            type  uint32;
            description
                "Number of flows bound to meter.";
        }

        leaf packet_in_count {
            type  uint64;
            description
                "Number of packets in input.";
        }

        leaf byte_in_count {
            type  uint64;
            description
                "Number of bytes in input.";
        }

        leaf duration_sec {
            type  uint32;
            description
                "Time meter has been alive in seconds.";
        }

        leaf duration_nsec {
            type  uint32;
            description
                "Time meter has been alive in nanoseconds
beyond duration_sec.";
        }

        list band_stats {
            key "packet_band_count";
            uses  ofp_meter_band_stats;

            description
                "The band_stats length is
inferred from the length field.";
        }



    }

    container ofp_meter_config {
        description
            "Body of reply to OFPMP_METER_CONFIG request. Meter configuration.";
        leaf flags {
            type  uint32;
            description
                "All OFPMF_  that apply.";
        }

        leaf meter_id {
            type  uint32;
            description
                "Meter instance.";
        }

        list bands {
            key "type";
            uses  ofp_meter_band_header;

            description
                "The bands length is
inferred from the length field.";
        }



    }

    container ofp_meter_features {
        description
            "Body of reply to OFPMP_METER_FEATURES request. Meter features.";
        leaf max_meter {
            type  uint32;
            description
                "Maximum number of meters.";
        }

        leaf band_types {
            type  uint32;
            description
                "Bitmaps of (1    OFPMBT_ ) values supported.";
        }

        leaf capabilities {
            type  uint32;
            description
                "Bitmaps of  ofp_meter_flags .";
        }

        leaf max_bands {
            type  uint32;
            description
                "Maximum bands per meters";
        }

        leaf max_color {
            type  uint32;
            description
                "Maximum color value";
        }



    }

    container ofp_experimenter_multipart_header {
        description
            "Body for ofp_multipart_request reply of type OFPMP_EXPERIMENTER.";
        leaf experimenter {
            type  uint32;
            description
                "Experimenter ID which takes the same form
as in struct ofp_experimenter_header.";
        }

        leaf exp_type {
            type  uint32;
            description
                "Experimenter defined.";
        }

        leaf data {
            type  binary;
            description
                "Experimenter-defined arbitrary additional data.";
        }



    }

    container ofp_experimenter_header {
        description
            "Experimenter extension.";
        leaf experimenter {
            type  uint32;
            description
                "ofp_header header;     Type OFPT_EXPERIMENTER.
Experimenter ID:
 - MSB 0: low-order bytes are IEEE OUI.
 - MSB != 0: defined by ONF.";
        }

        leaf exp_type {
            type  uint32;
            description
                "Experimenter defined.";
        }

        leaf data {
            type  binary;
            description
                "Experimenter-defined arbitrary additional data.";
        }



    }

    grouping ofp_queue_prop_header {
        description
            "Common description for a queue.";
        leaf property {
            type  uint32;
            description
                "One of OFPQT_.";
        }

        leaf len {
            type  uint32;
            description
                "Length of property, including this header.";
        }



    }

    container ofp_queue_prop_min_rate {
        description
            "Min-Rate queue property description.";
        container prop_header {
            uses  ofp_queue_prop_header;

            description
                "prop: OFPQT_MIN, len: 16.";
        }

        leaf rate {
            type  uint32;
            description
                "In 1 10 of a percent = 0; 1000 -  disabled.";
        }



    }

    container ofp_queue_prop_max_rate {
        description
            "Max-Rate queue property description.";
        container prop_header {
            uses  ofp_queue_prop_header;

            description
                "prop: OFPQT_MAX, len: 16.";
        }

        leaf rate {
            type  uint32;
            description
                "In 1 10 of a percent = 0; 1000 -  disabled.";
        }



    }

    container ofp_queue_prop_experimenter {
        description
            "Experimenter queue property description.";
        container prop_header {
            uses  ofp_queue_prop_header;

            description
                "prop: OFPQT_EXPERIMENTER";
        }

        leaf experimenter {
            type  uint32;
            description
                "Experimenter ID which takes the same
form as in struct
ofp_experimenter_header.";
        }

        leaf data {
            type  binary;
            description
                "Experimenter defined data.";
        }



    }

    grouping ofp_packet_queue {
        description
            "Full description for a queue.";
        leaf queue_id {
            type  uint32;
            description
                "id for the specific queue.";
        }

        leaf port {
            type  uint32;
            description
                "Port this queue is attached to.";
        }

        list properties {
            key "property";
            uses  ofp_queue_prop_header;

            description
                "List of properties.";
        }



    }

    container ofp_queue_get_config_request {
        description
            "Query for port queue configuration.";
        leaf port {
            type  uint32;
            description
                "ofp_header header;
Port to be queried. Should refer
to a valid physical port (i.e.  = OFPP_MAX),
or OFPP_ANY to request all configured
queues.";
        }



    }

    container ofp_queue_get_config_reply {
        description
            "Queue configuration for a given port.";
        leaf port {
            type  uint32;
            description
                "ofp_header header;";
        }

        list queues {
            key "queue_id";
            uses  ofp_packet_queue;

            description
                "List of configured queues.";
        }



    }

    container ofp_action_set_queue {
        description
            "OFPAT_SET_QUEUE action struct: send packets to given queue on port.";
        leaf type {
            type  uint32;
            description
                "OFPAT_SET_QUEUE.";
        }

        leaf queue_id {
            type  uint32;
            description
                "Queue id for the packets.";
        }



    }

    container ofp_queue_stats_request {
        description
            "";
        leaf port_no {
            type  uint32;
            description
                "All ports if OFPP_ANY.";
        }

        leaf queue_id {
            type  uint32;
            description
                "All queues if OFPQ_ALL.";
        }



    }

    container ofp_queue_stats {
        description
            "";
        leaf port_no {
            type  uint32;
            description
                "";
        }

        leaf queue_id {
            type  uint32;
            description
                "Queue i.d";
        }

        leaf tx_bytes {
            type  uint64;
            description
                "Number of transmitted bytes.";
        }

        leaf tx_packets {
            type  uint64;
            description
                "Number of transmitted packets.";
        }

        leaf tx_errors {
            type  uint64;
            description
                "Number of packets dropped due to overrun.";
        }

        leaf duration_sec {
            type  uint32;
            description
                "Time queue has been alive in seconds.";
        }

        leaf duration_nsec {
            type  uint32;
            description
                "Time queue has been alive in nanoseconds
beyond duration_sec.";
        }



    }

    container ofp_role_request {
        description
            "Role request and reply message.";
        leaf role {
            type  ofp_controller_role;

            description
                "ofp_header header;           Type OFPT_ROLE_REQUEST OFPT_ROLE_REPLY.
One of OFPCR_ROLE_ .";
        }

        leaf generation_id {
            type  uint64;
            description
                "Master Election Generation Id";
        }



    }

    container ofp_async_config {
        description
            "Asynchronous message configuration.";
        list packet_in_mask {
            key "packet_in_mask";
            leaf packet_in_mask {
                type  uint32;
                description
                    "ofp_header header;       OFPT_GET_ASYNC_REPLY or OFPT_SET_ASYNC.
Bitmasks of OFPR_  values.";
            }
            description
                "ofp_header header;       OFPT_GET_ASYNC_REPLY or OFPT_SET_ASYNC.
Bitmasks of OFPR_  values.";
        }

        list port_status_mask {
            key "port_status_mask";
            leaf port_status_mask {
                type  uint32;
                description
                    "Bitmasks of OFPPR_  values.";
            }
            description
                "Bitmasks of OFPPR_  values.";
        }

        list flow_removed_mask {
            key "flow_removed_mask";
            leaf flow_removed_mask {
                type  uint32;
                description
                    "Bitmasks of OFPRR_  values.";
            }
            description
                "Bitmasks of OFPRR_  values.";
        }



    }

    grouping FlowTableUpdate {
        description
            "ADDITIONAL VOLTHA SPECIFIC MESSAGE TYPES, AIDING RPC CALLS";
        leaf id {
            type  string;
            description
                "Device.id or LogicalDevice.id";
        }

        container flow_mod {
            uses  ofp_flow_mod;

            description
                "";
        }



    }

    grouping FlowGroupTableUpdate {
        description
            "";
        leaf id {
            type  string;
            description
                "Device.id or LogicalDevice.id";
        }

        container group_mod {
            uses  ofp_group_mod;

            description
                "";
        }



    }

    grouping Flows {
        description
            "";
        list items {
            key "id";
            uses  ofp_flow_stats;

            description
                "";
        }



    }

    grouping FlowGroups {
        description
            "";
        list items {
            key "type";
            uses  ofp_group_entry;

            description
                "";
        }



    }

    grouping PacketIn {
        description
            "";
        leaf id {
            type  string;
            description
                "LogicalDevice.id";
        }

        container packet_in {
            uses  ofp_packet_in;

            description
                "";
        }



    }

    grouping PacketOut {
        description
            "";
        leaf id {
            type  string;
            description
                "LogicalDevice.id";
        }

        container packet_out {
            uses  ofp_packet_out;

            description
                "";
        }



    }

    grouping ChangeEvent {
        description
            "";
        leaf id {
            type  string;
            description
                "LogicalDevice.id";
        }



        choice choice_0 {
            case port_status {
                container port_status {
                    uses  ofp_port_status;

                    description
                        "";
                }
            }
        }


    }


    /*  Health related services" */
    rpc HealthService-GetHealthStatus {
        description
            "Return current health status of a Voltha instance";
        input {
            uses  Empty;

        }
        output {
            uses  HealthStatus;

        }
    }

    /*  Cluster-wide Voltha APIs

 These APIs are potentially dispatched to the leader of the Voltha cluster,
 to a specific Voltha instance which owns the given device or logical device." */
    rpc VolthaGlobalService-GetVoltha {
        description
            "Get high level information on the Voltha cluster";
        input {
            uses  Empty;

        }
        output {
            uses  Voltha_grouping; 
        }
    }

    rpc VolthaGlobalService-ListVolthaInstances {
        description
            "List all Voltha cluster instances";
        input {
            uses  Empty;

        }
        output {
            uses  VolthaInstances_grouping; 
        }
    }

    rpc VolthaGlobalService-GetVolthaInstance {
        description
            "Get details on a Voltha cluster instance";
        input {
            uses  ID;

        }
        output {
            uses  VolthaInstance_grouping; 
        }
    }

    rpc VolthaGlobalService-ListLogicalDevices {
        description
            "List all logical devices managed by the Voltha cluster";
        input {
            uses  Empty;

        }
        output {
            uses  LogicalDevices;

        }
    }

    rpc VolthaGlobalService-GetLogicalDevice {
        description
            "Get additional information on a given logical device";
        input {
            uses  ID;

        }
        output {
            uses  LogicalDevice;

        }
    }

    rpc VolthaGlobalService-ListLogicalDevicePorts {
        description
            "List ports of a logical device";
        input {
            uses  ID;

        }
        output {
            uses  LogicalPorts;

        }
    }

    rpc VolthaGlobalService-ListLogicalDeviceFlows {
        description
            "List all flows of a logical device";
        input {
            uses  ID;

        }
        output {
            uses  Flows;

        }
    }

    rpc VolthaGlobalService-UpdateLogicalDeviceFlowTable {
        description
            "Update flow table for logical device";
        input {
            uses  FlowTableUpdate;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaGlobalService-ListLogicalDeviceFlowGroups {
        description
            "List all flow groups of a logical device";
        input {
            uses  ID;

        }
        output {
            uses  FlowGroups;

        }
    }

    rpc VolthaGlobalService-UpdateLogicalDeviceFlowGroupTable {
        description
            "Update group table for device";
        input {
            uses  FlowGroupTableUpdate;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaGlobalService-ListDevices {
        description
            "List all physical devices controlled by the Voltha cluster";
        input {
            uses  Empty;

        }
        output {
            uses  Devices;

        }
    }

    rpc VolthaGlobalService-GetDevice {
        description
            "Get more information on a given physical device";
        input {
            uses  ID;

        }
        output {
            uses  Device;

        }
    }

    rpc VolthaGlobalService-CreateDevice {
        description
            "Pre-provision a new physical device";
        input {
            uses  Device;

        }
        output {
            uses  Device;

        }
    }

    rpc VolthaGlobalService-EnableDevice {
        description
            "Enable a device.  If the device was in pre-provisioned state then it
 will tansition to ENABLED state.  If it was is DISABLED state then it
 will tansition to ENABLED state as well.";
        input {
            uses  ID;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaGlobalService-DisableDevice {
        description
            "Disable a device";
        input {
            uses  ID;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaGlobalService-RebootDevice {
        description
            "Reboot a device";
        input {
            uses  ID;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaGlobalService-DeleteDevice {
        description
            "Delete a device";
        input {
            uses  ID;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaGlobalService-ListDevicePorts {
        description
            "List ports of a device";
        input {
            uses  ID;

        }
        output {
            uses  Ports;

        }
    }

    rpc VolthaGlobalService-ListDevicePmConfigs {
        description
            "List pm config of a device";
        input {
            uses  ID;

        }
        output {
            uses  PmConfigs;

        }
    }

    rpc VolthaGlobalService-UpdateDevicePmConfigs {
        description
            "Update the pm config of a device";
        input {
            uses  PmConfigs;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaGlobalService-ListDeviceFlows {
        description
            "List all flows of a device";
        input {
            uses  ID;

        }
        output {
            uses  Flows;

        }
    }

    rpc VolthaGlobalService-ListDeviceFlowGroups {
        description
            "List all flow groups of a device";
        input {
            uses  ID;

        }
        output {
            uses  FlowGroups;

        }
    }

    rpc VolthaGlobalService-ListDeviceTypes {
        description
            "List device types known to Voltha";
        input {
            uses  Empty;

        }
        output {
            uses  DeviceTypes;

        }
    }

    rpc VolthaGlobalService-GetDeviceType {
        description
            "Get additional information on a device type";
        input {
            uses  ID;

        }
        output {
            uses  DeviceType;

        }
    }

    rpc VolthaGlobalService-ListDeviceGroups {
        description
            "List all device sharding groups";
        input {
            uses  Empty;

        }
        output {
            uses  DeviceGroups;

        }
    }

    rpc VolthaGlobalService-GetDeviceGroup {
        description
            "Get additional information on a device group";
        input {
            uses  ID;

        }
        output {
            uses  DeviceGroup;

        }
    }

    rpc VolthaGlobalService-CreateAlarmFilter {
        description
            "";
        input {
            uses  AlarmFilter;

        }
        output {
            uses  AlarmFilter;

        }
    }

    rpc VolthaGlobalService-GetAlarmFilter {
        description
            "";
        input {
            uses  ID;

        }
        output {
            uses  AlarmFilter;

        }
    }

    rpc VolthaGlobalService-UpdateAlarmFilter {
        description
            "";
        input {
            uses  AlarmFilter;

        }
        output {
            uses  AlarmFilter;

        }
    }

    rpc VolthaGlobalService-DeleteAlarmFilter {
        description
            "";
        input {
            uses  ID;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaGlobalService-ListAlarmFilters {
        description
            "";
        input {
            uses  Empty;

        }
        output {
            uses  AlarmFilters;

        }
    }


    /*  Per-instance APIs

 These APIs are always served locally by the Voltha instance on which the
 call is made." */
    rpc VolthaLocalService-GetVolthaInstance {
        description
            "Get information on this Voltha instance";
        input {
            uses  Empty;

        }
        output {
            uses  VolthaInstance_grouping; 
        }
    }

    rpc VolthaLocalService-GetHealth {
        description
            "Get the health state of the Voltha instance";
        input {
            uses  Empty;

        }
        output {
            uses  HealthStatus;

        }
    }

    rpc VolthaLocalService-ListAdapters {
        description
            "List all active adapters (plugins) in this Voltha instance";
        input {
            uses  Empty;

        }
        output {
            uses  Adapters;

        }
    }

    rpc VolthaLocalService-ListLogicalDevices {
        description
            "List all logical devices managed by this Voltha instance";
        input {
            uses  Empty;

        }
        output {
            uses  LogicalDevices;

        }
    }

    rpc VolthaLocalService-GetLogicalDevice {
        description
            "Get additional information on given logical device";
        input {
            uses  ID;

        }
        output {
            uses  LogicalDevice;

        }
    }

    rpc VolthaLocalService-ListLogicalDevicePorts {
        description
            "List ports of a logical device";
        input {
            uses  ID;

        }
        output {
            uses  LogicalPorts;

        }
    }

    rpc VolthaLocalService-ListLogicalDeviceFlows {
        description
            "List all flows of a logical device";
        input {
            uses  ID;

        }
        output {
            uses  Flows;

        }
    }

    rpc VolthaLocalService-UpdateLogicalDeviceFlowTable {
        description
            "Update flow table for logical device";
        input {
            uses  FlowTableUpdate;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaLocalService-ListLogicalDeviceFlowGroups {
        description
            "List all flow groups of a logical device";
        input {
            uses  ID;

        }
        output {
            uses  FlowGroups;

        }
    }

    rpc VolthaLocalService-UpdateLogicalDeviceFlowGroupTable {
        description
            "Update group table for logical device";
        input {
            uses  FlowGroupTableUpdate;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaLocalService-ListDevices {
        description
            "List all physical devices managed by this Voltha instance";
        input {
            uses  Empty;

        }
        output {
            uses  Devices;

        }
    }

    rpc VolthaLocalService-GetDevice {
        description
            "Get additional information on this device";
        input {
            uses  ID;

        }
        output {
            uses  Device;

        }
    }

    rpc VolthaLocalService-CreateDevice {
        description
            "Pre-provision a new physical device";
        input {
            uses  Device;

        }
        output {
            uses  Device;

        }
    }

    rpc VolthaLocalService-EnableDevice {
        description
            "Enable a device.  If the device was in pre-provisioned state then it
 will tansition to ENABLED state.  If it was is DISABLED state then it
 will tansition to ENABLED state as well.";
        input {
            uses  ID;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaLocalService-DisableDevice {
        description
            "Disable a device";
        input {
            uses  ID;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaLocalService-RebootDevice {
        description
            "Reboot a device";
        input {
            uses  ID;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaLocalService-DeleteDevice {
        description
            "Delete a device";
        input {
            uses  ID;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaLocalService-ListDevicePorts {
        description
            "List ports of a device";
        input {
            uses  ID;

        }
        output {
            uses  Ports;

        }
    }

    rpc VolthaLocalService-ListDevicePmConfigs {
        description
            "List pm config of a device";
        input {
            uses  ID;

        }
        output {
            uses  PmConfigs;

        }
    }

    rpc VolthaLocalService-UpdateDevicePmConfigs {
        description
            "Update the pm config of a device";
        input {
            uses  PmConfigs;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaLocalService-ListDeviceFlows {
        description
            "List all flows of a device";
        input {
            uses  ID;

        }
        output {
            uses  Flows;

        }
    }

    rpc VolthaLocalService-ListDeviceFlowGroups {
        description
            "List all flow groups of a device";
        input {
            uses  ID;

        }
        output {
            uses  FlowGroups;

        }
    }

    rpc VolthaLocalService-ListDeviceTypes {
        description
            "List device types know to Voltha instance";
        input {
            uses  Empty;

        }
        output {
            uses  DeviceTypes;

        }
    }

    rpc VolthaLocalService-GetDeviceType {
        description
            "Get additional information on given device type";
        input {
            uses  ID;

        }
        output {
            uses  DeviceType;

        }
    }

    rpc VolthaLocalService-ListDeviceGroups {
        description
            "List device sharding groups managed by this Voltha instance";
        input {
            uses  Empty;

        }
        output {
            uses  DeviceGroups;

        }
    }

    rpc VolthaLocalService-GetDeviceGroup {
        description
            "Get more information on given device shard";
        input {
            uses  ID;

        }
        output {
            uses  DeviceGroup;

        }
    }

    rpc VolthaLocalService-StreamPacketsOut {
        description
            "Stream control packets to the dataplane
This does not have an HTTP representation";
        input {
            uses  PacketOut;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaLocalService-ReceivePacketsIn {
        description
            "Receive control packet stream
This does not have an HTTP representation";
        input {
            uses  Empty;

        }
        output {
            uses  PacketIn;

        }
    }

    rpc VolthaLocalService-ReceiveChangeEvents {
        description
            "This does not have an HTTP representation";
        input {
            uses  Empty;

        }
        output {
            uses  ChangeEvent;

        }
    }

    rpc VolthaLocalService-CreateAlarmFilter {
        description
            "";
        input {
            uses  AlarmFilter;

        }
        output {
            uses  AlarmFilter;

        }
    }

    rpc VolthaLocalService-GetAlarmFilter {
        description
            "";
        input {
            uses  ID;

        }
        output {
            uses  AlarmFilter;

        }
    }

    rpc VolthaLocalService-UpdateAlarmFilter {
        description
            "";
        input {
            uses  AlarmFilter;

        }
        output {
            uses  AlarmFilter;

        }
    }

    rpc VolthaLocalService-DeleteAlarmFilter {
        description
            "";
        input {
            uses  ID;

        }
        output {
            uses  Empty;

        }
    }

    rpc VolthaLocalService-ListAlarmFilters {
        description
            "";
        input {
            uses  Empty;

        }
        output {
            uses  AlarmFilters;

        }
    }


}
