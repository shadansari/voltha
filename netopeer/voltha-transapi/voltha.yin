<!--
Copyright 2017-present Open Networking Foundation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yang:yin:1" xmlns:voltha="urn:opencord:params:xml:ns:voltha:voltha" name="voltha">
  <namespace uri="urn:opencord:params:xml:ns:voltha:voltha"/>
  <prefix value="voltha"/>
  <organization>
    <text>CORD</text>
  </organization>
  <contact>
    <text> Any name</text>
  </contact>
  <description>
    <text/>
  </description>
  <revision date="2016-11-15">
    <description>
      <text>Initial revision.</text>
    </description>
    <reference>
      <text>reference</text>
    </reference>
  </revision>
  <grouping name="DeviceGroup">
    <description>
      <text/>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <list name="logical_devices">
      <key value="id"/>
      <uses name="LogicalDevice"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="devices">
      <key value="id"/>
      <uses name="Device"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="DeviceGroups">
    <description>
      <text/>
    </description>
    <list name="items">
      <key value="id"/>
      <uses name="DeviceGroup"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <typedef name="AlarmFilterRuleKey">
    <type name="enumeration">
      <enum name="id">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="type">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="severity">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="resource_id">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="category">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="device_id">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text/>
    </description>
  </typedef>
  <grouping name="AlarmFilterRule">
    <description>
      <text/>
    </description>
    <leaf name="key">
      <type name="AlarmFilterRuleKey"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="value">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
  </grouping>
  <grouping name="AlarmFilter">
    <description>
      <text/>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <list name="rules">
      <key value="key"/>
      <uses name="AlarmFilterRule"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="AlarmFilters">
    <description>
      <text/>
    </description>
    <list name="filters">
      <key value="id"/>
      <uses name="AlarmFilter"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <container name="VolthaInstance">
    <description>
      <text>Top-level (root) node for a Voltha Instance</text>
    </description>
    <leaf name="instance_id">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="version">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="log_level">
      <type name="LogLevel"/>
      <description>
        <text/>
      </description>
    </leaf>
    <container name="health">
      <uses name="HealthStatus"/>
      <description>
        <text/>
      </description>
    </container>
    <list name="adapters">
      <key value="id"/>
      <uses name="Adapter"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="logical_devices">
      <key value="id"/>
      <uses name="LogicalDevice"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="devices">
      <key value="id"/>
      <uses name="Device"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="device_types">
      <key value="id"/>
      <uses name="DeviceType"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="device_groups">
      <key value="id"/>
      <uses name="DeviceGroup"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="alarm_filters">
      <key value="id"/>
      <uses name="AlarmFilter"/>
      <description>
        <text/>
      </description>
    </list>
  </container>
  <container name="VolthaInstances">
    <description>
      <text/>
    </description>
    <list name="items">
      <key value="items"/>
      <leaf name="items">
        <type name="string"/>
        <description>
          <text/>
        </description>
      </leaf>
      <description>
        <text/>
      </description>
    </list>
  </container>
  <container name="Voltha">
    <description>
      <text>Voltha representing the entire Voltha cluster</text>
    </description>
    <leaf name="version">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="log_level">
      <type name="LogLevel"/>
      <description>
        <text/>
      </description>
    </leaf>
    <list name="instances">
      <key value="instance_id"/>
      <uses name="VolthaInstance_grouping"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="adapters">
      <key value="id"/>
      <uses name="Adapter"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="logical_devices">
      <key value="id"/>
      <uses name="LogicalDevice"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="devices">
      <key value="id"/>
      <uses name="Device"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="device_groups">
      <key value="id"/>
      <uses name="DeviceGroup"/>
      <description>
        <text/>
      </description>
    </list>
  </container>
  <grouping name="VolthaInstance_grouping">
    <description>
      <text>Top-level (root) node for a Voltha Instance</text>
    </description>
    <leaf name="instance_id">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="version">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="log_level">
      <type name="LogLevel"/>
      <description>
        <text/>
      </description>
    </leaf>
    <container name="health">
      <uses name="HealthStatus"/>
      <description>
        <text/>
      </description>
    </container>
    <list name="adapters">
      <key value="id"/>
      <uses name="Adapter"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="logical_devices">
      <key value="id"/>
      <uses name="LogicalDevice"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="devices">
      <key value="id"/>
      <uses name="Device"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="device_types">
      <key value="id"/>
      <uses name="DeviceType"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="device_groups">
      <key value="id"/>
      <uses name="DeviceGroup"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="alarm_filters">
      <key value="id"/>
      <uses name="AlarmFilter"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="VolthaInstances_grouping">
    <description>
      <text/>
    </description>
    <list name="items">
      <key value="items"/>
      <leaf name="items">
        <type name="string"/>
        <description>
          <text/>
        </description>
      </leaf>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="Voltha_grouping">
    <description>
      <text>Voltha representing the entire Voltha cluster</text>
    </description>
    <leaf name="version">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="log_level">
      <type name="LogLevel"/>
      <description>
        <text/>
      </description>
    </leaf>
    <list name="instances">
      <key value="instance_id"/>
      <uses name="VolthaInstance_grouping"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="adapters">
      <key value="id"/>
      <uses name="Adapter"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="logical_devices">
      <key value="id"/>
      <uses name="LogicalDevice"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="devices">
      <key value="id"/>
      <uses name="Device"/>
      <description>
        <text/>
      </description>
    </list>
    <list name="device_groups">
      <key value="id"/>
      <uses name="DeviceGroup"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="AdapterConfig">
    <description>
      <text/>
    </description>
    <leaf name="log_level">
      <type name="LogLevel"/>
      <description>
        <text>Common adapter config attributes here</text>
      </description>
    </leaf>
    <container name="additional_config">
      <uses name="Any"/>
      <description>
        <text>Custom (vendor-specific) configuration attributes</text>
      </description>
    </container>
  </grouping>
  <grouping name="Adapter">
    <description>
      <text>Adapter (software plugin)</text>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text>Unique name of adapter, matching the python packate name under
voltha adapters.</text>
      </description>
    </leaf>
    <leaf name="vendor">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="version">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <container name="config">
      <uses name="AdapterConfig"/>
      <description>
        <text>Adapter configuration</text>
      </description>
    </container>
    <container name="additional_description">
      <uses name="Any"/>
      <description>
        <text>Custom descriptors and custom configuration</text>
      </description>
    </container>
    <list name="logical_device_ids">
      <key value="logical_device_ids"/>
      <leaf name="logical_device_ids">
        <type name="string"/>
        <description>
          <text>Logical devices  owned </text>
        </description>
      </leaf>
      <description>
        <text>Logical devices  owned </text>
      </description>
    </list>
  </grouping>
  <grouping name="Adapters">
    <description>
      <text/>
    </description>
    <list name="items">
      <key value="id"/>
      <uses name="Adapter"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="Any">
    <description>
      <text>`Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

Foo foo = ...;
Any any;
any.PackFrom(foo);
...
if (any.UnpackTo(&amp;amp;foo))
...


Example 2: Pack and unpack a message in Java.

Foo foo = ...;
Any any = Any.pack(foo);
...
if (any.is(Foo.class))
foo = any.unpack(Foo.class);


Example 3: Pack and unpack a message in Python.

foo = Foo(...)
any = Any()
any.Pack(foo)
...
if any.Is(Foo.DESCRIPTOR):
any.Unpack(foo)
...

The pack methods provided by protobuf library will by default use
'type.googleapis.com full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last ' '
in the type URL, for example  foo.bar.com x y.z  will yield type
name  y.z .


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

package google.profile;
message Person
string first_name = 1;
string last_name = 2;



@type :  type.googleapis.com google.profile.Person ,
firstName :  string ,
lastName :  string


If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message  google.protobuf.Duration   ):


@type :  type.googleapis.com google.protobuf.Duration ,
value :  1.212s
</text>
    </description>
    <leaf name="type_url">
      <type name="string"/>
      <description>
        <text>A URL resource name whose content describes the type of the
serialized protocol buffer message.

For URLs which use the scheme `http`, `https`, or no scheme, the
following restrictions and interpretations apply:

If no scheme is provided, `https` is assumed.
The last segment of the URL's path must represent the fully
qualified name of the type (as in `path google.protobuf.Duration`).
The name should be in a canonical form (e.g., leading  .  is
not accepted).
An HTTP GET on the URL must yield a  google.protobuf.Type
value in binary format, or produce an error.
Applications are allowed to cache lookup results based on the
URL, or have them precompiled into a binary to avoid any
lookup. Therefore, binary compatibility needs to be preserved
on changes to types. (Use versioned type names to manage
breaking changes.)

Schemes other than `http`, `https` (or the empty scheme) might be
used with implementation specific semantics.</text>
      </description>
    </leaf>
    <leaf name="value">
      <type name="binary"/>
      <description>
        <text>Must be a valid serialized protocol buffer of the above specified type.</text>
      </description>
    </leaf>
  </grouping>
  <typedef name="LogLevel">
    <type name="enumeration">
      <enum name="DEBUG">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="INFO">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="WARNING">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="ERROR">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="CRITICAL">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Logging verbosity level</text>
    </description>
  </typedef>
  <typedef name="AdminState">
    <type name="enumeration">
      <enum name="UNKNOWN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="PREPROVISIONED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="ENABLED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="DISABLED">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Administrative State</text>
    </description>
  </typedef>
  <typedef name="OperStatus">
    <type name="enumeration">
      <enum name="UNKNOWN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="DISCOVERED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="ACTIVATING">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="TESTING">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="ACTIVE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="FAILED">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Operational Status</text>
    </description>
  </typedef>
  <typedef name="ConnectStatus">
    <type name="enumeration">
      <enum name="UNKNOWN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="UNREACHABLE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="REACHABLE">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Connectivity Status</text>
    </description>
  </typedef>
  <grouping name="ID">
    <description>
      <text>Convey a resource identifier</text>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
  </grouping>
  <typedef name="PortType">
    <type name="enumeration">
      <enum name="UNKNOWN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="ETHERNET_NNI">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="ETHERNET_UNI">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="PON_OLT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="PON_ONU">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text/>
    </description>
  </typedef>
  <grouping name="DeviceType">
    <description>
      <text>A Device Type</text>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text>Unique name for the device type</text>
      </description>
    </leaf>
    <leaf name="adapter">
      <type name="string"/>
      <description>
        <text>Name of the adapter that handles device type</text>
      </description>
    </leaf>
    <leaf name="accepts_bulk_flow_update">
      <type name="boolean"/>
      <description>
        <text>Capabilitities</text>
      </description>
    </leaf>
    <leaf name="accepts_add_remove_flow_updates">
      <type name="boolean"/>
      <description>
        <text/>
      </description>
    </leaf>
  </grouping>
  <grouping name="DeviceTypes">
    <description>
      <text>A plurality of device types</text>
    </description>
    <list name="items">
      <key value="id"/>
      <uses name="DeviceType"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="PmConfig">
    <description>
      <text/>
    </description>
    <leaf name="name">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="type">
      <type name="PmType"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="enabled">
      <type name="boolean"/>
      <description>
        <text>Whether or not this metric makes it to Kafka</text>
      </description>
    </leaf>
    <leaf name="sample_freq">
      <type name="uint32"/>
      <description>
        <text>Sample rate in 10ths of a second</text>
      </description>
    </leaf>
    <typedef name="PmType">
      <type name="enumeration">
        <enum name="COUNTER">
          <description>
            <text/>
          </description>
        </enum>
        <enum name="GUAGE">
          <description>
            <text/>
          </description>
        </enum>
        <enum name="STATE">
          <description>
            <text/>
          </description>
        </enum>
      </type>
      <description>
        <text/>
      </description>
    </typedef>
  </grouping>
  <grouping name="PmGroupConfig">
    <description>
      <text/>
    </description>
    <leaf name="group_name">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="group_freq">
      <type name="uint32"/>
      <description>
        <text>Frequency applicable to the grop</text>
      </description>
    </leaf>
    <leaf name="enabled">
      <type name="boolean"/>
      <description>
        <text>Enable disable group level only</text>
      </description>
    </leaf>
    <list name="metrics">
      <key value="name"/>
      <uses name="PmConfig"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="PmConfigs">
    <description>
      <text/>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text>To work around a chameleon POST bug</text>
      </description>
    </leaf>
    <leaf name="default_freq">
      <type name="uint32"/>
      <description>
        <text>Default sample rate</text>
      </description>
    </leaf>
    <leaf name="grouped">
      <type name="boolean"/>
      <description>
        <text>Forces group names and group semantics</text>
      </description>
    </leaf>
    <leaf name="freq_override">
      <type name="boolean"/>
      <description>
        <text>Allows Pm to set an individual sample frequency</text>
      </description>
    </leaf>
    <list name="groups">
      <key value="group_name"/>
      <uses name="PmGroupConfig"/>
      <description>
        <text>The groups if grouped is true</text>
      </description>
    </list>
    <list name="metrics">
      <key value="name"/>
      <uses name="PmConfig"/>
      <description>
        <text>The metrics themselves if grouped is false.</text>
      </description>
    </list>
  </grouping>
  <grouping name="PeerPort">
    <description>
      <text/>
    </description>
    <leaf name="device_id">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="port_no">
      <type name="uint32"/>
      <description>
        <text/>
      </description>
    </leaf>
  </grouping>
  <grouping name="Port">
    <description>
      <text/>
    </description>
    <leaf name="port_no">
      <type name="uint32"/>
      <description>
        <text>Device-unique port number</text>
      </description>
    </leaf>
    <leaf name="label">
      <type name="string"/>
      <description>
        <text>Arbitrary port label</text>
      </description>
    </leaf>
    <leaf name="type">
      <type name="PortType"/>
      <description>
        <text>Type of port</text>
      </description>
    </leaf>
    <leaf name="admin_state">
      <type name="AdminState"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="oper_status">
      <type name="OperStatus"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="device_id">
      <type name="string"/>
      <description>
        <text>Unique .id of device that owns this port</text>
      </description>
    </leaf>
    <list name="peers">
      <key value="device_id"/>
      <uses name="PeerPort"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="Ports">
    <description>
      <text/>
    </description>
    <list name="items">
      <key value="port_no"/>
      <uses name="Port"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="ProxyAddress">
    <description>
      <text/>
    </description>
    <leaf name="device_id">
      <type name="string"/>
      <description>
        <text>Which device to use as proxy to this device</text>
      </description>
    </leaf>
    <leaf name="channel_id">
      <type name="uint32"/>
      <description>
        <text>Sub-address within proxy</text>
      </description>
    </leaf>
    <leaf name="onu_id">
      <type name="uint32"/>
      <description>
        <text>onu identifier; optional</text>
      </description>
    </leaf>
    <leaf name="onu_session_id">
      <type name="uint32"/>
      <description>
        <text>session identifier for the ONU; optional</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="Device">
    <description>
      <text>A Physical Device instance</text>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text>Voltha's device identifier</text>
      </description>
    </leaf>
    <leaf name="type">
      <type name="string"/>
      <description>
        <text>Device type, refers to one of the registered device types</text>
      </description>
    </leaf>
    <leaf name="root">
      <type name="boolean"/>
      <description>
        <text>Is this device a root device. Each logical switch has one root
device that is associated with the logical flow switch.</text>
      </description>
    </leaf>
    <leaf name="parent_id">
      <type name="string"/>
      <description>
        <text>Parent device id, in the device tree (for a root device, the parent_id
is the logical_device.id)</text>
      </description>
    </leaf>
    <leaf name="parent_port_no">
      <type name="uint32"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="vendor">
      <type name="string"/>
      <description>
        <text>Vendor, version, serial number, etc.</text>
      </description>
    </leaf>
    <leaf name="model">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="hardware_version">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="firmware_version">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="software_version">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="serial_number">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="adapter">
      <type name="string"/>
      <description>
        <text>Addapter that takes care of device</text>
      </description>
    </leaf>
    <leaf name="vlan">
      <type name="uint32"/>
      <description>
        <text>Device contact on vlan (if 0, no vlan)</text>
      </description>
    </leaf>
    <container name="proxy_address">
      <uses name="ProxyAddress"/>
      <description>
        <text/>
      </description>
    </container>
    <leaf name="admin_state">
      <type name="AdminState"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="oper_status">
      <type name="OperStatus"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="reason">
      <type name="string"/>
      <description>
        <text>Used in FAILED state</text>
      </description>
    </leaf>
    <leaf name="connect_status">
      <type name="ConnectStatus"/>
      <description>
        <text/>
      </description>
    </leaf>
    <container name="custom">
      <uses name="Any"/>
      <description>
        <text>Device type specific attributes
TODO additional common attribute here</text>
      </description>
    </container>
    <list name="ports">
      <key value="port_no"/>
      <uses name="Port"/>
      <description>
        <text/>
      </description>
    </list>
    <container name="flows">
      <uses name="Flows"/>
      <description>
        <text/>
      </description>
    </container>
    <container name="flow_groups">
      <uses name="FlowGroups"/>
      <description>
        <text/>
      </description>
    </container>
    <container name="pm_configs">
      <uses name="PmConfigs"/>
      <description>
        <text>PmConfigs will eventually converted to a child node of the
device to falicitata callbacks and to simplify manipulation.</text>
      </description>
    </container>
    <choice name="choice_0">
      <case name="mac_address">
        <leaf name="mac_address">
          <type name="string"/>
          <description>
            <text>Device contact MAC address (format:  xx:xx:xx:xx:xx:xx )</text>
          </description>
        </leaf>
      </case>
      <case name="ipv4_address">
        <leaf name="ipv4_address">
          <type name="string"/>
          <description>
            <text>Device contact IPv4 address (format:  a.b.c.d  or can use hostname too)</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_address">
        <leaf name="ipv6_address">
          <type name="string"/>
          <description>
            <text>Device contact IPv6 address using the canonical string form
( xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx )</text>
          </description>
        </leaf>
      </case>
      <case name="host_and_port">
        <leaf name="host_and_port">
          <type name="string"/>
          <description>
            <text/>
          </description>
        </leaf>
      </case>
    </choice>
  </grouping>
  <grouping name="Devices">
    <description>
      <text/>
    </description>
    <list name="items">
      <key value="id"/>
      <uses name="Device"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="Empty">
    <description>
      <text>A generic empty message that you can re-use to avoid defining duplicated
empty messages in your APIs. A typical example is to use it as the request
or the response type of an API method. For instance:

service Foo
rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);


The JSON representation for `Empty` is empty JSON object `  `.</text>
    </description>
  </grouping>
  <grouping name="HealthStatus">
    <description>
      <text>Encode health status of a Voltha instance</text>
    </description>
    <leaf name="state">
      <type name="HealthState"/>
      <description>
        <text>Current state of health of this Voltha instance</text>
      </description>
    </leaf>
    <typedef name="HealthState">
      <type name="enumeration">
        <enum name="HEALTHY">
          <description>
            <text/>
          </description>
        </enum>
        <enum name="OVERLOADED">
          <description>
            <text/>
          </description>
        </enum>
        <enum name="DYING">
          <description>
            <text/>
          </description>
        </enum>
      </type>
      <description>
        <text>Health states</text>
      </description>
    </typedef>
  </grouping>
  <grouping name="LogicalPort">
    <description>
      <text/>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <container name="ofp_port">
      <uses name="ofp_port"/>
      <description>
        <text/>
      </description>
    </container>
    <leaf name="device_id">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="device_port_no">
      <type name="uint32"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="root_port">
      <type name="boolean"/>
      <description>
        <text/>
      </description>
    </leaf>
  </grouping>
  <grouping name="LogicalPorts">
    <description>
      <text/>
    </description>
    <list name="items">
      <key value="id"/>
      <uses name="LogicalPort"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="LogicalDevice">
    <description>
      <text/>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text>unique id of logical device</text>
      </description>
    </leaf>
    <leaf name="datapath_id">
      <type name="uint64"/>
      <description>
        <text>unique datapath id for the logical device (used by the SDN controller)</text>
      </description>
    </leaf>
    <container name="desc">
      <uses name="ofp_desc"/>
      <description>
        <text>device description</text>
      </description>
    </container>
    <container name="switch_features">
      <uses name="ofp_switch_features"/>
      <description>
        <text>device features</text>
      </description>
    </container>
    <leaf name="root_device_id">
      <type name="string"/>
      <description>
        <text>name of the root device anchoring logical device</text>
      </description>
    </leaf>
    <list name="ports">
      <key value="id"/>
      <uses name="LogicalPort"/>
      <description>
        <text>logical device ports</text>
      </description>
    </list>
    <container name="flows">
      <uses name="Flows"/>
      <description>
        <text>flows configured on the logical device</text>
      </description>
    </container>
    <container name="flow_groups">
      <uses name="FlowGroups"/>
      <description>
        <text>flow groups configured on the logical device</text>
      </description>
    </container>
  </grouping>
  <grouping name="LogicalDevices">
    <description>
      <text/>
    </description>
    <list name="items">
      <key value="id"/>
      <uses name="LogicalDevice"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <typedef name="Access">
    <type name="enumeration">
      <enum name="CONFIG">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="READ_ONLY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="REAL_TIME">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text/>
    </description>
  </typedef>
  <container name="ChildNode">
    <description>
      <text/>
    </description>
    <leaf name="key">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
  </container>
  <typedef name="ofp_port_no">
    <type name="enumeration">
      <enum name="OFPP_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPP_MAX">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPP_IN_PORT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPP_TABLE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPP_NORMAL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPP_FLOOD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPP_ALL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPP_CONTROLLER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPP_LOCAL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPP_ANY">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Port numbering. Ports are numbered starting from 1.Version number:
OpenFlow versions released: 0x01 = 1.0 ; 0x02 = 1.1 ; 0x03 = 1.2
0x04 = 1.3
The most significant bit in the version field is reserved and must
be set to zero.
#define OFP_VERSION   0x04
#define PIPELINE_TABLES 64
#define OFP_MAX_TABLE_NAME_LEN 32
#define OFP_MAX_PORT_NAME_LEN  16
Official IANA registered port for OpenFlow.#define OFP_TCP_PORT  6653
#define OFP_SSL_PORT  6653
#define OFP_ETH_ALEN 6             Bytes in an Ethernet address.   </text>
    </description>
  </typedef>
  <typedef name="ofp_type">
    <type name="enumeration">
      <enum name="OFPT_HELLO">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_ERROR">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_ECHO_REQUEST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_ECHO_REPLY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_FEATURES_REQUEST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_FEATURES_REPLY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_GET_CONFIG_REQUEST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_GET_CONFIG_REPLY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_SET_CONFIG">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_PACKET_IN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_FLOW_REMOVED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_PORT_STATUS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_PACKET_OUT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_FLOW_MOD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_GROUP_MOD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_PORT_MOD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_TABLE_MOD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_MULTIPART_REQUEST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_MULTIPART_REPLY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_BARRIER_REQUEST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_BARRIER_REPLY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_QUEUE_GET_CONFIG_REQUEST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_QUEUE_GET_CONFIG_REPLY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_ROLE_REQUEST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_ROLE_REPLY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_GET_ASYNC_REQUEST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_GET_ASYNC_REPLY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_SET_ASYNC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPT_METER_MOD">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text/>
    </description>
  </typedef>
  <typedef name="ofp_hello_elem_type">
    <type name="enumeration">
      <enum name="OFPHET_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPHET_VERSIONBITMAP">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Hello elements types.</text>
    </description>
  </typedef>
  <typedef name="ofp_config_flags">
    <type name="enumeration">
      <enum name="OFPC_FRAG_NORMAL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPC_FRAG_DROP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPC_FRAG_REASM">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPC_FRAG_MASK">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>#define OFP_DEFAULT_MISS_SEND_LEN   128</text>
    </description>
  </typedef>
  <typedef name="ofp_table_config">
    <type name="enumeration">
      <enum name="OFPTC_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTC_DEPRECATED_MASK">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Flags to configure the table. Reserved for future use.</text>
    </description>
  </typedef>
  <typedef name="ofp_table">
    <type name="enumeration">
      <enum name="OFPTT_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTT_MAX">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTT_ALL">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Table numbering. Tables can use any number up to OFPT_MAX.</text>
    </description>
  </typedef>
  <typedef name="ofp_capabilities">
    <type name="enumeration">
      <enum name="OFPC_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPC_FLOW_STATS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPC_TABLE_STATS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPC_PORT_STATS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPC_GROUP_STATS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPC_IP_REASM">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPC_QUEUE_STATS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPC_PORT_BLOCKED">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Capabilities supported by the datapath.</text>
    </description>
  </typedef>
  <typedef name="ofp_port_config">
    <type name="enumeration">
      <enum name="OFPPC_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPC_PORT_DOWN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPC_NO_RECV">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPC_NO_FWD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPC_NO_PACKET_IN">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Flags to indicate behavior of the physical port.  These flags are
used in ofp_port to describe the current configuration.  They are
used in the ofp_port_mod message to configure the port's behavior.</text>
    </description>
  </typedef>
  <typedef name="ofp_port_state">
    <type name="enumeration">
      <enum name="OFPPS_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPS_LINK_DOWN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPS_BLOCKED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPS_LIVE">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Current state of the physical port.  These are not configurable from
the controller.</text>
    </description>
  </typedef>
  <typedef name="ofp_port_features">
    <type name="enumeration">
      <enum name="OFPPF_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_10MB_HD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_10MB_FD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_100MB_HD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_100MB_FD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_1GB_HD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_1GB_FD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_10GB_FD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_40GB_FD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_100GB_FD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_1TB_FD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_OTHER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_COPPER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_FIBER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_AUTONEG">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_PAUSE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPF_PAUSE_ASYM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Features of ports available in a datapath.</text>
    </description>
  </typedef>
  <typedef name="ofp_port_reason">
    <type name="enumeration">
      <enum name="OFPPR_ADD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPR_DELETE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPR_MODIFY">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>What changed about the physical port</text>
    </description>
  </typedef>
  <typedef name="ofp_match_type">
    <type name="enumeration">
      <enum name="OFPMT_STANDARD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMT_OXM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>The match type indicates the match structure (set of fields that compose the
match) in use. The match type is placed in the type field at the beginning
of all match structures. The  OpenFlow Extensible Match  type corresponds
to OXM TLV format described below and must be supported by all OpenFlow
switches. Extensions that define other match types may be published on the
ONF wiki. Support for extensions is optional.
## -------------------------- #### OpenFlow Extensible Match. #### -------------------------- ##</text>
    </description>
  </typedef>
  <typedef name="ofp_oxm_class">
    <type name="enumeration">
      <enum name="OFPXMC_NXM_0">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMC_NXM_1">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMC_OPENFLOW_BASIC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMC_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>OXM Class IDs.
The high order bit differentiate reserved classes from member classes.
Classes 0x0000 to 0x7FFF are member classes, allocated by ONF.
Classes 0x8000 to 0xFFFE are reserved classes, reserved for standardisation.
Components of a OXM TLV header.
Those macros are not valid for the experimenter class, macros for the
experimenter class will depend on the experimenter header used.#define OXM_HEADER__(CLASS, FIELD, HASMASK, LENGTH)
(((CLASS)    16) | ((FIELD)    9) | ((HASMASK)    8) | (LENGTH))
#define OXM_HEADER(CLASS, FIELD, LENGTH)
OXM_HEADER__(CLASS, FIELD, 0, LENGTH)
#define OXM_HEADER_W(CLASS, FIELD, LENGTH)
OXM_HEADER__(CLASS, FIELD, 1, (LENGTH)   2)
#define OXM_CLASS(HEADER) ((HEADER)    16)
#define OXM_FIELD(HEADER) (((HEADER)    9) &amp;amp; 0x7f)
#define OXM_TYPE(HEADER) (((HEADER)    9) &amp;amp; 0x7fffff)
#define OXM_HASMASK(HEADER) (((HEADER)    8) &amp;amp; 1)
#define OXM_LENGTH(HEADER) ((HEADER) &amp;amp; 0xff)

#define OXM_MAKE_WILD_HEADER(HEADER)
OXM_HEADER_W(OXM_CLASS(HEADER), OXM_FIELD(HEADER), OXM_LENGTH(HEADER))</text>
    </description>
  </typedef>
  <typedef name="oxm_ofb_field_types">
    <type name="enumeration">
      <enum name="OFPXMT_OFB_IN_PORT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IN_PHY_PORT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_METADATA">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ETH_DST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ETH_SRC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ETH_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_VLAN_VID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_VLAN_PCP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IP_DSCP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IP_ECN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IP_PROTO">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IPV4_SRC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IPV4_DST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_TCP_SRC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_TCP_DST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_UDP_SRC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_UDP_DST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_SCTP_SRC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_SCTP_DST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ICMPV4_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ICMPV4_CODE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ARP_OP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ARP_SPA">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ARP_TPA">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ARP_SHA">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ARP_THA">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IPV6_SRC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IPV6_DST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IPV6_FLABEL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ICMPV6_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_ICMPV6_CODE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IPV6_ND_TARGET">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IPV6_ND_SLL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IPV6_ND_TLL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_MPLS_LABEL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_MPLS_TC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_MPLS_BOS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_PBB_ISID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_TUNNEL_ID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPXMT_OFB_IPV6_EXTHDR">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>OXM Flow field types for OpenFlow basic class.</text>
    </description>
  </typedef>
  <typedef name="ofp_vlan_id">
    <type name="enumeration">
      <enum name="OFPVID_NONE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPVID_PRESENT">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>The VLAN id is 12-bits, so we can use the entire 16 bits to indicate
special conditions.</text>
    </description>
  </typedef>
  <typedef name="ofp_ipv6exthdr_flags">
    <type name="enumeration">
      <enum name="OFPIEH_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIEH_NONEXT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIEH_ESP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIEH_AUTH">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIEH_DEST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIEH_FRAG">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIEH_ROUTER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIEH_HOP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIEH_UNREP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIEH_UNSEQ">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Bit definitions for IPv6 Extension Header pseudo-field.#define OFP_VLAN_NONE      OFPVID_NONE</text>
    </description>
  </typedef>
  <typedef name="ofp_action_type">
    <type name="enumeration">
      <enum name="OFPAT_OUTPUT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_COPY_TTL_OUT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_COPY_TTL_IN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_SET_MPLS_TTL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_DEC_MPLS_TTL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_PUSH_VLAN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_POP_VLAN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_PUSH_MPLS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_POP_MPLS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_SET_QUEUE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_GROUP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_SET_NW_TTL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_DEC_NW_TTL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_SET_FIELD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_PUSH_PBB">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_POP_PBB">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPAT_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>## ----------------- #### OpenFlow Actions. #### ----------------- ##</text>
    </description>
  </typedef>
  <typedef name="ofp_controller_max_len">
    <type name="enumeration">
      <enum name="OFPCML_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPCML_MAX">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPCML_NO_BUFFER">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text/>
    </description>
  </typedef>
  <typedef name="ofp_instruction_type">
    <type name="enumeration">
      <enum name="OFPIT_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIT_GOTO_TABLE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIT_WRITE_METADATA">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIT_WRITE_ACTIONS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIT_APPLY_ACTIONS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIT_CLEAR_ACTIONS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIT_METER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPIT_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>## ---------------------- #### OpenFlow Instructions. #### ---------------------- ##</text>
    </description>
  </typedef>
  <typedef name="ofp_flow_mod_command">
    <type name="enumeration">
      <enum name="OFPFC_ADD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFC_MODIFY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFC_MODIFY_STRICT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFC_DELETE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFC_DELETE_STRICT">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>## --------------------------- #### OpenFlow Flow Modification. #### --------------------------- ##</text>
    </description>
  </typedef>
  <typedef name="ofp_flow_mod_flags">
    <type name="enumeration">
      <enum name="OFPFF_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFF_SEND_FLOW_REM">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFF_CHECK_OVERLAP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFF_RESET_COUNTS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFF_NO_PKT_COUNTS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFF_NO_BYT_COUNTS">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Value used in  idle_timeout  and  hard_timeout  to indicate that the entry
is permanent.#define OFP_FLOW_PERMANENT 0
By default, choose a priority in the middle.#define OFP_DEFAULT_PRIORITY 0x8000</text>
    </description>
  </typedef>
  <typedef name="ofp_group">
    <type name="enumeration">
      <enum name="OFPG_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPG_MAX">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPG_ALL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPG_ANY">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Group numbering. Groups can use any number up to OFPG_MAX.</text>
    </description>
  </typedef>
  <typedef name="ofp_group_mod_command">
    <type name="enumeration">
      <enum name="OFPGC_ADD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGC_MODIFY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGC_DELETE">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Group commands</text>
    </description>
  </typedef>
  <typedef name="ofp_group_type">
    <type name="enumeration">
      <enum name="OFPGT_ALL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGT_SELECT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGT_INDIRECT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGT_FF">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Group types.  Values in the range  128; 255  are reserved for experimental
use.</text>
    </description>
  </typedef>
  <typedef name="ofp_packet_in_reason">
    <type name="enumeration">
      <enum name="OFPR_NO_MATCH">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPR_ACTION">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPR_INVALID_TTL">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Why is this packet being sent to the controller?</text>
    </description>
  </typedef>
  <typedef name="ofp_flow_removed_reason">
    <type name="enumeration">
      <enum name="OFPRR_IDLE_TIMEOUT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPRR_HARD_TIMEOUT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPRR_DELETE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPRR_GROUP_DELETE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPRR_METER_DELETE">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Why was this flow removed?</text>
    </description>
  </typedef>
  <typedef name="ofp_meter">
    <type name="enumeration">
      <enum name="OFPM_ZERO">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPM_MAX">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPM_SLOWPATH">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPM_CONTROLLER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPM_ALL">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Meter numbering. Flow meters can use any number up to OFPM_MAX.</text>
    </description>
  </typedef>
  <typedef name="ofp_meter_band_type">
    <type name="enumeration">
      <enum name="OFPMBT_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMBT_DROP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMBT_DSCP_REMARK">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMBT_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Meter band types</text>
    </description>
  </typedef>
  <typedef name="ofp_meter_mod_command">
    <type name="enumeration">
      <enum name="OFPMC_ADD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMC_MODIFY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMC_DELETE">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Meter commands</text>
    </description>
  </typedef>
  <typedef name="ofp_meter_flags">
    <type name="enumeration">
      <enum name="OFPMF_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMF_KBPS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMF_PKTPS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMF_BURST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMF_STATS">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Meter configuration flags</text>
    </description>
  </typedef>
  <typedef name="ofp_error_type">
    <type name="enumeration">
      <enum name="OFPET_HELLO_FAILED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_BAD_REQUEST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_BAD_ACTION">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_BAD_INSTRUCTION">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_BAD_MATCH">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_FLOW_MOD_FAILED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_GROUP_MOD_FAILED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_PORT_MOD_FAILED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_TABLE_MOD_FAILED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_QUEUE_OP_FAILED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_SWITCH_CONFIG_FAILED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_ROLE_REQUEST_FAILED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_METER_MOD_FAILED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_TABLE_FEATURES_FAILED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPET_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Values for 'type' in ofp_error_message.  These values are immutable: they
will not change in future versions of the protocol (although new values may
be added).</text>
    </description>
  </typedef>
  <typedef name="ofp_hello_failed_code">
    <type name="enumeration">
      <enum name="OFPHFC_INCOMPATIBLE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPHFC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_HELLO_FAILED.  'data' contains an
ASCII text string that may give failure details.</text>
    </description>
  </typedef>
  <typedef name="ofp_bad_request_code">
    <type name="enumeration">
      <enum name="OFPBRC_BAD_VERSION">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_BAD_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_BAD_MULTIPART">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_BAD_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_BAD_EXP_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_BAD_LEN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_BUFFER_EMPTY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_BUFFER_UNKNOWN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_BAD_TABLE_ID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_IS_SLAVE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_BAD_PORT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_BAD_PACKET">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBRC_MULTIPART_BUFFER_OVERFLOW">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_BAD_REQUEST.  'data' contains at least
the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_bad_action_code">
    <type name="enumeration">
      <enum name="OFPBAC_BAD_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_LEN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_EXP_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_OUT_PORT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_ARGUMENT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_TOO_MANY">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_QUEUE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_OUT_GROUP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_MATCH_INCONSISTENT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_UNSUPPORTED_ORDER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_TAG">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_SET_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_SET_LEN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBAC_BAD_SET_ARGUMENT">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_BAD_ACTION.  'data' contains at least
the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_bad_instruction_code">
    <type name="enumeration">
      <enum name="OFPBIC_UNKNOWN_INST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBIC_UNSUP_INST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBIC_BAD_TABLE_ID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBIC_UNSUP_METADATA">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBIC_UNSUP_METADATA_MASK">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBIC_BAD_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBIC_BAD_EXP_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBIC_BAD_LEN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBIC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_BAD_INSTRUCTION.  'data' contains at
least the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_bad_match_code">
    <type name="enumeration">
      <enum name="OFPBMC_BAD_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_BAD_LEN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_BAD_TAG">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_BAD_DL_ADDR_MASK">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_BAD_NW_ADDR_MASK">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_BAD_WILDCARDS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_BAD_FIELD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_BAD_VALUE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_BAD_MASK">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_BAD_PREREQ">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_DUP_FIELD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPBMC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_BAD_MATCH.  'data' contains at least
the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_flow_mod_failed_code">
    <type name="enumeration">
      <enum name="OFPFMFC_UNKNOWN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFMFC_TABLE_FULL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFMFC_BAD_TABLE_ID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFMFC_OVERLAP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFMFC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFMFC_BAD_TIMEOUT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFMFC_BAD_COMMAND">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPFMFC_BAD_FLAGS">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_FLOW_MOD_FAILED.  'data' contains
at least the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_group_mod_failed_code">
    <type name="enumeration">
      <enum name="OFPGMFC_GROUP_EXISTS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_INVALID_GROUP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_WEIGHT_UNSUPPORTED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_OUT_OF_GROUPS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_OUT_OF_BUCKETS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_CHAINING_UNSUPPORTED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_WATCH_UNSUPPORTED">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_LOOP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_UNKNOWN_GROUP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_CHAINED_GROUP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_BAD_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_BAD_COMMAND">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_BAD_BUCKET">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_BAD_WATCH">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGMFC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_GROUP_MOD_FAILED.  'data' contains
at least the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_port_mod_failed_code">
    <type name="enumeration">
      <enum name="OFPPMFC_BAD_PORT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPMFC_BAD_HW_ADDR">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPMFC_BAD_CONFIG">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPMFC_BAD_ADVERTISE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPPMFC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_PORT_MOD_FAILED.  'data' contains
at least the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_table_mod_failed_code">
    <type name="enumeration">
      <enum name="OFPTMFC_BAD_TABLE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTMFC_BAD_CONFIG">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTMFC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_TABLE_MOD_FAILED.  'data' contains
at least the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_queue_op_failed_code">
    <type name="enumeration">
      <enum name="OFPQOFC_BAD_PORT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPQOFC_BAD_QUEUE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPQOFC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error msg 'code' values for OFPET_QUEUE_OP_FAILED. 'data' contains
at least the first 64 bytes of the failed request</text>
    </description>
  </typedef>
  <typedef name="ofp_switch_config_failed_code">
    <type name="enumeration">
      <enum name="OFPSCFC_BAD_FLAGS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPSCFC_BAD_LEN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPSCFC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_SWITCH_CONFIG_FAILED. 'data' contains
at least the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_role_request_failed_code">
    <type name="enumeration">
      <enum name="OFPRRFC_STALE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPRRFC_UNSUP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPRRFC_BAD_ROLE">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_ROLE_REQUEST_FAILED. 'data' contains
at least the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_meter_mod_failed_code">
    <type name="enumeration">
      <enum name="OFPMMFC_UNKNOWN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_METER_EXISTS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_INVALID_METER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_UNKNOWN_METER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_BAD_COMMAND">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_BAD_FLAGS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_BAD_RATE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_BAD_BURST">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_BAD_BAND">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_BAD_BAND_VALUE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_OUT_OF_METERS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMMFC_OUT_OF_BANDS">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_METER_MOD_FAILED.  'data' contains
at least the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_table_features_failed_code">
    <type name="enumeration">
      <enum name="OFPTFFC_BAD_TABLE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFFC_BAD_METADATA">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFFC_BAD_TYPE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFFC_BAD_LEN">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFFC_BAD_ARGUMENT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFFC_EPERM">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>ofp_error_msg 'code' values for OFPET_TABLE_FEATURES_FAILED. 'data' contains
at least the first 64 bytes of the failed request.</text>
    </description>
  </typedef>
  <typedef name="ofp_multipart_type">
    <type name="enumeration">
      <enum name="OFPMP_DESC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_FLOW">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_AGGREGATE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_TABLE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_PORT_STATS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_QUEUE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_GROUP">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_GROUP_DESC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_GROUP_FEATURES">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_METER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_METER_CONFIG">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_METER_FEATURES">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_TABLE_FEATURES">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_PORT_DESC">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMP_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text/>
    </description>
  </typedef>
  <typedef name="ofp_multipart_request_flags">
    <type name="enumeration">
      <enum name="OFPMPF_REQ_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMPF_REQ_MORE">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Backward compatibility with 1.3.1 - avoid breaking the API.#define ofp_multipart_types ofp_multipart_type</text>
    </description>
  </typedef>
  <typedef name="ofp_multipart_reply_flags">
    <type name="enumeration">
      <enum name="OFPMPF_REPLY_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPMPF_REPLY_MORE">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text/>
    </description>
  </typedef>
  <typedef name="ofp_table_feature_prop_type">
    <type name="enumeration">
      <enum name="OFPTFPT_INSTRUCTIONS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_INSTRUCTIONS_MISS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_NEXT_TABLES">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_NEXT_TABLES_MISS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_WRITE_ACTIONS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_WRITE_ACTIONS_MISS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_APPLY_ACTIONS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_APPLY_ACTIONS_MISS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_MATCH">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_WILDCARDS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_WRITE_SETFIELD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_WRITE_SETFIELD_MISS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_APPLY_SETFIELD">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_APPLY_SETFIELD_MISS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPTFPT_EXPERIMENTER_MISS">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Table Feature property types.
Low order bit cleared indicates a property for a regular Flow Entry.
Low order bit set indicates a property for the Table-Miss Flow Entry.</text>
    </description>
  </typedef>
  <typedef name="ofp_group_capabilities">
    <type name="enumeration">
      <enum name="OFPGFC_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGFC_SELECT_WEIGHT">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGFC_SELECT_LIVENESS">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGFC_CHAINING">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPGFC_CHAINING_CHECKS">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Group configuration flagsBackward compatibility with 1.3.1 - avoid breaking the API.#define ofp_group_desc_stats ofp_group_desc</text>
    </description>
  </typedef>
  <typedef name="ofp_queue_properties">
    <type name="enumeration">
      <enum name="OFPQT_INVALID">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPQT_MIN_RATE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPQT_MAX_RATE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPQT_EXPERIMENTER">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>All ones is used to indicate all queues in a port (for stats retrieval).#define OFPQ_ALL      0xffffffff
Min rate   1000 means not configured.#define OFPQ_MIN_RATE_UNCFG      0xffff
Max rate   1000 means not configured.#define OFPQ_MAX_RATE_UNCFG      0xffff</text>
    </description>
  </typedef>
  <typedef name="ofp_controller_role">
    <type name="enumeration">
      <enum name="OFPCR_ROLE_NOCHANGE">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPCR_ROLE_EQUAL">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPCR_ROLE_MASTER">
        <description>
          <text/>
        </description>
      </enum>
      <enum name="OFPCR_ROLE_SLAVE">
        <description>
          <text/>
        </description>
      </enum>
    </type>
    <description>
      <text>Controller roles.Configures the  role  of the sending controller.  The default role is:

- Equal (OFPCR_ROLE_EQUAL), which allows the controller access to all
OpenFlow features. All controllers have equal responsibility.

The other possible roles are a related pair:

- Master (OFPCR_ROLE_MASTER) is equivalent to Equal, except that there
may be at most one Master controller at a time: when a controller
configures itself as Master, any existing Master is demoted to the
Slave role.

- Slave (OFPCR_ROLE_SLAVE) allows the controller read-only access to
OpenFlow features.  In particular attempts to modify the flow table
will be rejected with an OFPBRC_EPERM error.

Slave controllers do not receive OFPT_PACKET_IN or OFPT_FLOW_REMOVED
messages, but they do receive OFPT_PORT_STATUS messages.</text>
    </description>
  </typedef>
  <container name="ofp_header">
    <description>
      <text>Header on all OpenFlow packets.</text>
    </description>
    <leaf name="version">
      <type name="uint32"/>
      <description>
        <text>OFP_VERSION.</text>
      </description>
    </leaf>
    <leaf name="type">
      <type name="ofp_type"/>
      <description>
        <text>One of the OFPT_ constants.</text>
      </description>
    </leaf>
    <leaf name="xid">
      <type name="uint32"/>
      <description>
        <text>Transaction id associated with this packet.
Replies use the same id as was in the request
to facilitate pairing.</text>
      </description>
    </leaf>
  </container>
  <grouping name="ofp_hello_elem_header">
    <description>
      <text>Common header for all Hello Elements</text>
    </description>
    <leaf name="type">
      <type name="ofp_hello_elem_type"/>
      <description>
        <text>One of OFPHET_ .</text>
      </description>
    </leaf>
    <choice name="choice_0">
      <case name="versionbitmap">
        <container name="versionbitmap">
          <uses name="ofp_hello_elem_versionbitmap"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
    </choice>
  </grouping>
  <grouping name="ofp_hello_elem_versionbitmap">
    <description>
      <text>Version bitmap Hello Element</text>
    </description>
    <list name="bitmaps">
      <key value="bitmaps"/>
      <leaf name="bitmaps">
        <type name="uint32"/>
        <description>
          <text>List of bitmaps - supported versions</text>
        </description>
      </leaf>
      <description>
        <text>List of bitmaps - supported versions</text>
      </description>
    </list>
  </grouping>
  <container name="ofp_hello">
    <description>
      <text>OFPT_HELLO.  This message includes zero or more hello elements having
variable size. Unknown elements types must be ignored skipped, to allow
for future extensions.ofp_header header;</text>
    </description>
    <list name="elements">
      <key value="type"/>
      <uses name="ofp_hello_elem_header"/>
      <description>
        <text>Hello element list0 or more</text>
      </description>
    </list>
  </container>
  <container name="ofp_switch_config">
    <description>
      <text>Switch configuration.</text>
    </description>
    <leaf name="flags">
      <type name="uint32"/>
      <description>
        <text>ofp_header header;
Bitmap of OFPC_  flags.</text>
      </description>
    </leaf>
    <leaf name="miss_send_len">
      <type name="uint32"/>
      <description>
        <text>Max bytes of packet that datapath
should send to the controller. See
ofp_controller_max_len for valid values.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_table_mod">
    <description>
      <text>Configure Modify behavior of a flow table</text>
    </description>
    <leaf name="table_id">
      <type name="uint32"/>
      <description>
        <text>ofp_header header;
ID of the table, OFPTT_ALL indicates all tables</text>
      </description>
    </leaf>
    <leaf name="config">
      <type name="uint32"/>
      <description>
        <text>Bitmap of OFPTC_  flags</text>
      </description>
    </leaf>
  </container>
  <grouping name="ofp_port">
    <description>
      <text>Description of a port</text>
    </description>
    <leaf name="port_no">
      <type name="uint32"/>
      <description>
        <text/>
      </description>
    </leaf>
    <list name="hw_addr">
      <key value="hw_addr"/>
      <leaf name="hw_addr">
        <type name="uint32"/>
        <description>
          <text> OFP_ETH_ALEN ;</text>
        </description>
      </leaf>
      <description>
        <text> OFP_ETH_ALEN ;</text>
      </description>
    </list>
    <leaf name="name">
      <type name="string"/>
      <description>
        <text>Null-terminated</text>
      </description>
    </leaf>
    <leaf name="config">
      <type name="uint32"/>
      <description>
        <text>Bitmap of OFPPC_  flags.</text>
      </description>
    </leaf>
    <leaf name="state">
      <type name="uint32"/>
      <description>
        <text>Bitmap of OFPPS_  flags.</text>
      </description>
    </leaf>
    <leaf name="curr">
      <type name="uint32"/>
      <description>
        <text>Bitmaps of OFPPF_  that describe features.  All bits zeroed if
unsupported or unavailable.Current features.</text>
      </description>
    </leaf>
    <leaf name="advertised">
      <type name="uint32"/>
      <description>
        <text>Features being advertised by the port.</text>
      </description>
    </leaf>
    <leaf name="supported">
      <type name="uint32"/>
      <description>
        <text>Features supported by the port.</text>
      </description>
    </leaf>
    <leaf name="peer">
      <type name="uint32"/>
      <description>
        <text>Features advertised by peer.</text>
      </description>
    </leaf>
    <leaf name="curr_speed">
      <type name="uint32"/>
      <description>
        <text>Current port bitrate in kbps.</text>
      </description>
    </leaf>
    <leaf name="max_speed">
      <type name="uint32"/>
      <description>
        <text>Max port bitrate in kbps</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_switch_features">
    <description>
      <text>Switch features.</text>
    </description>
    <leaf name="datapath_id">
      <type name="uint64"/>
      <description>
        <text>ofp_header header;
Datapath unique ID.  The lower 48-bits are for
a MAC address, while the upper 16-bits are
implementer-defined.</text>
      </description>
    </leaf>
    <leaf name="n_buffers">
      <type name="uint32"/>
      <description>
        <text>Max packets buffered at once.</text>
      </description>
    </leaf>
    <leaf name="n_tables">
      <type name="uint32"/>
      <description>
        <text>Number of tables supported by datapath.</text>
      </description>
    </leaf>
    <leaf name="auxiliary_id">
      <type name="uint32"/>
      <description>
        <text>Identify auxiliary connections</text>
      </description>
    </leaf>
    <leaf name="capabilities">
      <type name="uint32"/>
      <description>
        <text>Features.Bitmap of support  ofp_capabilities .</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_port_status">
    <description>
      <text>A physical port has changed in the datapath</text>
    </description>
    <leaf name="reason">
      <type name="ofp_port_reason"/>
      <description>
        <text>ofp_header header;
One of OFPPR_ .</text>
      </description>
    </leaf>
    <container name="desc">
      <uses name="ofp_port"/>
      <description>
        <text/>
      </description>
    </container>
  </grouping>
  <container name="ofp_port_mod">
    <description>
      <text>Modify behavior of the physical port</text>
    </description>
    <leaf name="port_no">
      <type name="uint32"/>
      <description>
        <text>ofp_header header;</text>
      </description>
    </leaf>
    <list name="hw_addr">
      <key value="hw_addr"/>
      <leaf name="hw_addr">
        <type name="uint32"/>
        <description>
          <text> OFP_ETH_ALEN ;</text>
        </description>
      </leaf>
      <description>
        <text> OFP_ETH_ALEN ;</text>
      </description>
    </list>
    <leaf name="config">
      <type name="uint32"/>
      <description>
        <text>The hardware address is not
configurable.  This is used to
sanity-check the request, so it must
be the same as returned in an
ofp_port struct.Bitmap of OFPPC_  flags.</text>
      </description>
    </leaf>
    <leaf name="mask">
      <type name="uint32"/>
      <description>
        <text>Bitmap of OFPPC_  flags to be changed.</text>
      </description>
    </leaf>
    <leaf name="advertise">
      <type name="uint32"/>
      <description>
        <text>Bitmap of OFPPF_ .  Zero all bits to prevent
any action taking place.</text>
      </description>
    </leaf>
  </container>
  <grouping name="ofp_match">
    <description>
      <text>Fields to match against flows</text>
    </description>
    <leaf name="type">
      <type name="ofp_match_type"/>
      <description>
        <text>One of OFPMT_ </text>
      </description>
    </leaf>
    <list name="oxm_fields">
      <key value="oxm_class"/>
      <uses name="ofp_oxm_field"/>
      <description>
        <text>0 or more</text>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_oxm_field">
    <description>
      <text>OXM Flow match fields</text>
    </description>
    <leaf name="oxm_class">
      <type name="ofp_oxm_class"/>
      <description>
        <text/>
      </description>
    </leaf>
    <choice name="choice_0">
      <case name="ofb_field">
        <container name="ofb_field">
          <uses name="ofp_oxm_ofb_field"/>
          <description>
            <text>2 and 3 reserved for NXM_0 and NXM-1 OXM classes</text>
          </description>
        </container>
      </case>
      <case name="experimenter_field">
        <container name="experimenter_field">
          <uses name="ofp_oxm_experimenter_field"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
    </choice>
  </grouping>
  <grouping name="ofp_oxm_ofb_field">
    <description>
      <text>OXM OpenFlow Basic Match Field</text>
    </description>
    <leaf name="type">
      <type name="oxm_ofb_field_types"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="has_mask">
      <type name="boolean"/>
      <description>
        <text/>
      </description>
    </leaf>
    <choice name="choice_0">
      <case name="port">
        <leaf name="port">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_IN_PORT    OXM_HEADER  (0x8000, OFPXMT_OFB_IN_PORT, 4)
Used for OFPXMT_OFB_IN_PORTOpenFlow port on which the packet was received.
May be a physical port, a logical port, or the reserved port OFPP_LOCAL

Prereqs: None.

Format: 32-bit integer in network byte order.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="physical_port">
        <leaf name="physical_port">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_IN_PHY_PORT OXM_HEADER  (0x8000, OFPXMT_OFB_IN_PHY_PORT, 4)
Used for OFPXMT_OF_IN_PHY_PORTPhysical port on which the packet was received.

Consider a packet received on a tunnel interface defined over a link
aggregation group (LAG) with two physical port members.  If the tunnel
interface is the logical port bound to OpenFlow.  In this case,
OFPXMT_OF_IN_PORT is the tunnel's port number and OFPXMT_OF_IN_PHY_PORT is
the physical port number of the LAG on which the tunnel is configured.

When a packet is received directly on a physical port and not processed by a
logical port, OFPXMT_OF_IN_PORT and OFPXMT_OF_IN_PHY_PORT have the same
value.

This field is usually not available in a regular match and only available
in ofp_packet_in messages when it's different from OXM_OF_IN_PORT.

Prereqs: OXM_OF_IN_PORT must be present.

Format: 32-bit integer in network byte order.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="table_metadata">
        <leaf name="table_metadata">
          <type name="uint64"/>
          <description>
            <text>#define OXM_OF_METADATA   OXM_HEADER  (0x8000, OFPXMT_OFB_METADATA, 8)
#define OXM_OF_METADATA_W OXM_HEADER_W(0x8000, OFPXMT_OFB_METADATA, 8)
Used for OFPXMT_OFB_METADATATable metadata.

Prereqs: None.

Format: 64-bit integer in network byte order.

Masking: Arbitrary masks.</text>
          </description>
        </leaf>
      </case>
      <case name="eth_dst">
        <leaf name="eth_dst">
          <type name="binary"/>
          <description>
            <text>#define OXM_OF_ETH_DST    OXM_HEADER  (0x8000, OFPXMT_OFB_ETH_DST, 6)
#define OXM_OF_ETH_DST_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_ETH_DST, 6)
#define OXM_OF_ETH_SRC    OXM_HEADER  (0x8000, OFPXMT_OFB_ETH_SRC, 6)
#define OXM_OF_ETH_SRC_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_ETH_SRC, 6)
Used for OFPXMT_OFB_ETH_DST (exactly 6 bytes)Source or destination address in Ethernet header.

Prereqs: None.

Format: 48-bit Ethernet MAC address.

Masking: Arbitrary masks.</text>
          </description>
        </leaf>
      </case>
      <case name="eth_src">
        <leaf name="eth_src">
          <type name="binary"/>
          <description>
            <text>Used for OFPXMT_OFB_ETH_SRC (exactly 6 bytes)</text>
          </description>
        </leaf>
      </case>
      <case name="eth_type">
        <leaf name="eth_type">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_ETH_TYPE   OXM_HEADER  (0x8000, OFPXMT_OFB_ETH_TYPE,2)
Used for OFPXMT_OFB_ETH_TYPEPacket's Ethernet type.

Prereqs: None.

Format: 16-bit integer in network byte order.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="vlan_vid">
        <leaf name="vlan_vid">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_VLAN_VID   OXM_HEADER  (0x8000, OFPXMT_OFB_VLAN_VID, 2)
#define OXM_OF_VLAN_VID_W OXM_HEADER_W(0x8000, OFPXMT_OFB_VLAN_VID, 2)
Used for OFPXMT_OFB_VLAN_VID802.1Q VID.

For a packet with an 802.1Q header, this is the VLAN-ID (VID) from the
outermost tag, with the CFI bit forced to 1. For a packet with no 802.1Q
header, this has value OFPVID_NONE.

Prereqs: None.

Format: 16-bit integer in network byte order with bit 13 indicating
presence of VLAN header and 3 most-significant bits forced to 0.
Only the lower 13 bits have meaning.

Masking: Arbitrary masks.

This field can be used in various ways:

- If it is not constrained at all, the nx_match matches packets without
an 802.1Q header or with an 802.1Q header that has any VID value.

- Testing for an exact match with 0x0 matches only packets without
an 802.1Q header.

- Testing for an exact match with a VID value with CFI=1 matches packets
that have an 802.1Q header with a specified VID.

- Testing for an exact match with a nonzero VID value with CFI=0 does
not make sense.  The switch may reject this combination.

- Testing with nxm_value=0, nxm_mask=0x0fff matches packets with no 802.1Q
header or with an 802.1Q header with a VID of 0.

- Testing with nxm_value=0x1000, nxm_mask=0x1000 matches packets with
an 802.1Q header that has any VID value.</text>
          </description>
        </leaf>
      </case>
      <case name="vlan_pcp">
        <leaf name="vlan_pcp">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_VLAN_PCP   OXM_HEADER  (0x8000, OFPXMT_OFB_VLAN_PCP, 1)
Used for OFPXMT_OFB_VLAN_PCP802.1Q PCP.

For a packet with an 802.1Q header, this is the VLAN-PCP from the
outermost tag.  For a packet with no 802.1Q header, this has value
0.

Prereqs: OXM_OF_VLAN_VID must be different from OFPVID_NONE.

Format: 8-bit integer with 5 most-significant bits forced to 0.
Only the lower 3 bits have meaning.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="ip_dscp">
        <leaf name="ip_dscp">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_IP_DSCP     OXM_HEADER  (0x8000, OFPXMT_OFB_IP_DSCP, 1)
Used for OFPXMT_OFB_IP_DSCPThe Diff Serv Code Point (DSCP) bits of the IP header.
Part of the IPv4 ToS field or the IPv6 Traffic Class field.

Prereqs: OXM_OF_ETH_TYPE must be either 0x0800 or 0x86dd.

Format: 8-bit integer with 2 most-significant bits forced to 0.
Only the lower 6 bits have meaning.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="ip_ecn">
        <leaf name="ip_ecn">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_IP_ECN     OXM_HEADER  (0x8000, OFPXMT_OFB_IP_ECN, 1)
Used for OFPXMT_OFB_IP_ECNThe ECN bits of the IP header.
Part of the IPv4 ToS field or the IPv6 Traffic Class field.

Prereqs: OXM_OF_ETH_TYPE must be either 0x0800 or 0x86dd.

Format: 8-bit integer with 6 most-significant bits forced to 0.
Only the lower 2 bits have meaning.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="ip_proto">
        <leaf name="ip_proto">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_IP_PROTO   OXM_HEADER  (0x8000, OFPXMT_OFB_IP_PROTO, 1)
Used for OFPXMT_OFB_IP_PROTOThe  protocol  byte in the IP header.

Prereqs: OXM_OF_ETH_TYPE must be either 0x0800 or 0x86dd.

Format: 8-bit integer.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="ipv4_src">
        <leaf name="ipv4_src">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_IPV4_SRC     OXM_HEADER  (0x8000, OFPXMT_OFB_IPV4_SRC, 4)
#define OXM_OF_IPV4_SRC_W   OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV4_SRC, 4)
#define OXM_OF_IPV4_DST     OXM_HEADER  (0x8000, OFPXMT_OFB_IPV4_DST, 4)
#define OXM_OF_IPV4_DST_W   OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV4_DST, 4)
Used for OFPXMT_OFB_IPV4_SRCThe source or destination address in the IP header.

Prereqs: OXM_OF_ETH_TYPE must match 0x0800 exactly.

Format: 32-bit integer in network byte order.

Masking: Arbitrary masks.</text>
          </description>
        </leaf>
      </case>
      <case name="ipv4_dst">
        <leaf name="ipv4_dst">
          <type name="uint32"/>
          <description>
            <text>Used for OFPXMT_OFB_IPV4_DST</text>
          </description>
        </leaf>
      </case>
      <case name="tcp_src">
        <leaf name="tcp_src">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_TCP_SRC    OXM_HEADER  (0x8000, OFPXMT_OFB_TCP_SRC, 2)
#define OXM_OF_TCP_DST    OXM_HEADER  (0x8000, OFPXMT_OFB_TCP_DST, 2)
Used for OFPXMT_OFB_TCP_SRCThe source or destination port in the TCP header.

Prereqs:
OXM_OF_ETH_TYPE must be either 0x0800 or 0x86dd.
OXM_OF_IP_PROTO must match 6 exactly.

Format: 16-bit integer in network byte order.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="tcp_dst">
        <leaf name="tcp_dst">
          <type name="uint32"/>
          <description>
            <text>Used for OFPXMT_OFB_TCP_DST</text>
          </description>
        </leaf>
      </case>
      <case name="udp_src">
        <leaf name="udp_src">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_UDP_SRC    OXM_HEADER  (0x8000, OFPXMT_OFB_UDP_SRC, 2)
#define OXM_OF_UDP_DST    OXM_HEADER  (0x8000, OFPXMT_OFB_UDP_DST, 2)
Used for OFPXMT_OFB_UDP_SRCThe source or destination port in the UDP header.

Prereqs:
OXM_OF_ETH_TYPE must match either 0x0800 or 0x86dd.
OXM_OF_IP_PROTO must match 17 exactly.

Format: 16-bit integer in network byte order.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="udp_dst">
        <leaf name="udp_dst">
          <type name="uint32"/>
          <description>
            <text>Used for OFPXMT_OFB_UDP_DST</text>
          </description>
        </leaf>
      </case>
      <case name="sctp_src">
        <leaf name="sctp_src">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_SCTP_SRC   OXM_HEADER  (0x8000, OFPXMT_OFB_SCTP_SRC, 2)
#define OXM_OF_SCTP_DST   OXM_HEADER  (0x8000, OFPXMT_OFB_SCTP_DST, 2)
Used for OFPXMT_OFB_SCTP_SRCThe source or destination port in the SCTP header.

Prereqs:
OXM_OF_ETH_TYPE must match either 0x0800 or 0x86dd.
OXM_OF_IP_PROTO must match 132 exactly.

Format: 16-bit integer in network byte order.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="sctp_dst">
        <leaf name="sctp_dst">
          <type name="uint32"/>
          <description>
            <text>Used for OFPXMT_OFB_SCTP_DST</text>
          </description>
        </leaf>
      </case>
      <case name="icmpv4_type">
        <leaf name="icmpv4_type">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_ICMPV4_TYPE  OXM_HEADER  (0x8000, OFPXMT_OFB_ICMPV4_TYPE, 1)
#define OXM_OF_ICMPV4_CODE  OXM_HEADER  (0x8000, OFPXMT_OFB_ICMPV4_CODE, 1)
Used for OFPXMT_OFB_ICMPV4_TYPEThe type or code in the ICMP header.

Prereqs:
OXM_OF_ETH_TYPE must match 0x0800 exactly.
OXM_OF_IP_PROTO must match 1 exactly.

Format: 8-bit integer.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="icmpv4_code">
        <leaf name="icmpv4_code">
          <type name="uint32"/>
          <description>
            <text>Used for OFPXMT_OFB_ICMPV4_CODE</text>
          </description>
        </leaf>
      </case>
      <case name="arp_op">
        <leaf name="arp_op">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_ARP_OP     OXM_HEADER  (0x8000, OFPXMT_OFB_ARP_OP, 2)
Used for OFPXMT_OFB_ARP_OPARP opcode.

For an Ethernet+IP ARP packet, the opcode in the ARP header.  Always 0
otherwise.

Prereqs: OXM_OF_ETH_TYPE must match 0x0806 exactly.

Format: 16-bit integer in network byte order.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="arp_spa">
        <leaf name="arp_spa">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_ARP_SPA    OXM_HEADER  (0x8000, OFPXMT_OFB_ARP_SPA, 4)
#define OXM_OF_ARP_SPA_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_ARP_SPA, 4)
#define OXM_OF_ARP_TPA    OXM_HEADER  (0x8000, OFPXMT_OFB_ARP_TPA, 4)
#define OXM_OF_ARP_TPA_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_ARP_TPA, 4)
For OFPXMT_OFB_ARP_SPAFor an Ethernet+IP ARP packet, the source or target protocol address
in the ARP header.  Always 0 otherwise.

Prereqs: OXM_OF_ETH_TYPE must match 0x0806 exactly.

Format: 32-bit integer in network byte order.

Masking: Arbitrary masks.</text>
          </description>
        </leaf>
      </case>
      <case name="arp_tpa">
        <leaf name="arp_tpa">
          <type name="uint32"/>
          <description>
            <text>For OFPXMT_OFB_ARP_TPA</text>
          </description>
        </leaf>
      </case>
      <case name="arp_sha">
        <leaf name="arp_sha">
          <type name="binary"/>
          <description>
            <text>#define OXM_OF_ARP_SHA    OXM_HEADER   (0x8000, OFPXMT_OFB_ARP_SHA, 6)
#define OXM_OF_ARP_SHA_W  OXM_HEADER_W (0x8000, OFPXMT_OFB_ARP_SHA, 6)
#define OXM_OF_ARP_THA    OXM_HEADER   (0x8000, OFPXMT_OFB_ARP_THA, 6)
#define OXM_OF_ARP_THA_W  OXM_HEADER_W (0x8000, OFPXMT_OFB_ARP_THA, 6)
For OFPXMT_OFB_ARP_SHA (6 bytes)For an Ethernet+IP ARP packet, the source or target hardware address
in the ARP header.  Always 0 otherwise.

Prereqs: OXM_OF_ETH_TYPE must match 0x0806 exactly.

Format: 48-bit Ethernet MAC address.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="arp_tha">
        <leaf name="arp_tha">
          <type name="binary"/>
          <description>
            <text>For OFPXMT_OFB_ARP_THA (6 bytes)</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_src">
        <leaf name="ipv6_src">
          <type name="binary"/>
          <description>
            <text>#define OXM_OF_IPV6_SRC    OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_SRC, 16)
#define OXM_OF_IPV6_SRC_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV6_SRC, 16)
#define OXM_OF_IPV6_DST    OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_DST, 16)
#define OXM_OF_IPV6_DST_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV6_DST, 16)
For OFPXMT_OFB_IPV6_SRCThe source or destination address in the IPv6 header.

Prereqs: OXM_OF_ETH_TYPE must match 0x86dd exactly.

Format: 128-bit IPv6 address.

Masking: Arbitrary masks.</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_dst">
        <leaf name="ipv6_dst">
          <type name="binary"/>
          <description>
            <text>For OFPXMT_OFB_IPV6_DST</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_flabel">
        <leaf name="ipv6_flabel">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_IPV6_FLABEL   OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_FLABEL, 4)
#define OXM_OF_IPV6_FLABEL_W OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV6_FLABEL, 4)
For OFPXMT_OFB_IPV6_FLABELThe IPv6 Flow Label

Prereqs:
OXM_OF_ETH_TYPE must match 0x86dd exactly

Format: 32-bit integer with 12 most-significant bits forced to 0.
Only the lower 20 bits have meaning.

Masking: Arbitrary masks.</text>
          </description>
        </leaf>
      </case>
      <case name="icmpv6_type">
        <leaf name="icmpv6_type">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_ICMPV6_TYPE OXM_HEADER  (0x8000, OFPXMT_OFB_ICMPV6_TYPE, 1)
#define OXM_OF_ICMPV6_CODE OXM_HEADER  (0x8000, OFPXMT_OFB_ICMPV6_CODE, 1)
For OFPXMT_OFB_ICMPV6_TYPEThe type or code in the ICMPv6 header.

Prereqs:
OXM_OF_ETH_TYPE must match 0x86dd exactly.
OXM_OF_IP_PROTO must match 58 exactly.

Format: 8-bit integer.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="icmpv6_code">
        <leaf name="icmpv6_code">
          <type name="uint32"/>
          <description>
            <text>For OFPXMT_OFB_ICMPV6_CODE</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_nd_target">
        <leaf name="ipv6_nd_target">
          <type name="binary"/>
          <description>
            <text>#define OXM_OF_IPV6_ND_TARGET OXM_HEADER
(0x8000, OFPXMT_OFB_IPV6_ND_TARGET, 16)
For OFPXMT_OFB_IPV6_ND_TARGETThe target address in an IPv6 Neighbor Discovery message.

Prereqs:
OXM_OF_ETH_TYPE must match 0x86dd exactly.
OXM_OF_IP_PROTO must match 58 exactly.
OXM_OF_ICMPV6_TYPE must be either 135 or 136.

Format: 128-bit IPv6 address.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_nd_ssl">
        <leaf name="ipv6_nd_ssl">
          <type name="binary"/>
          <description>
            <text>#define OXM_OF_IPV6_ND_SLL  OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_ND_SLL, 6)
For OFPXMT_OFB_IPV6_ND_SLLThe source link-layer address option in an IPv6 Neighbor Discovery
message.

Prereqs:
OXM_OF_ETH_TYPE must match 0x86dd exactly.
OXM_OF_IP_PROTO must match 58 exactly.
OXM_OF_ICMPV6_TYPE must be exactly 135.

Format: 48-bit Ethernet MAC address.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_nd_tll">
        <leaf name="ipv6_nd_tll">
          <type name="binary"/>
          <description>
            <text>#define OXM_OF_IPV6_ND_TLL  OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_ND_TLL, 6)
For OFPXMT_OFB_IPV6_ND_TLLThe target link-layer address option in an IPv6 Neighbor Discovery
message.

Prereqs:
OXM_OF_ETH_TYPE must match 0x86dd exactly.
OXM_OF_IP_PROTO must match 58 exactly.
OXM_OF_ICMPV6_TYPE must be exactly 136.

Format: 48-bit Ethernet MAC address.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="mpls_label">
        <leaf name="mpls_label">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_MPLS_LABEL  OXM_HEADER  (0x8000, OFPXMT_OFB_MPLS_LABEL, 4)
For OFPXMT_OFB_MPLS_LABELThe LABEL in the first MPLS shim header.

Prereqs:
OXM_OF_ETH_TYPE must match 0x8847 or 0x8848 exactly.

Format: 32-bit integer in network byte order with 12 most-significant
bits forced to 0. Only the lower 20 bits have meaning.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="mpls_tc">
        <leaf name="mpls_tc">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_MPLS_TC     OXM_HEADER  (0x8000, OFPXMT_OFB_MPLS_TC, 1)
For OFPXMT_OFB_MPLS_TCThe TC in the first MPLS shim header.

Prereqs:
OXM_OF_ETH_TYPE must match 0x8847 or 0x8848 exactly.

Format: 8-bit integer with 5 most-significant bits forced to 0.
Only the lower 3 bits have meaning.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="mpls_bos">
        <leaf name="mpls_bos">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_MPLS_BOS     OXM_HEADER  (0x8000, OFPXMT_OFB_MPLS_BOS, 1)
For OFPXMT_OFB_MPLS_BOSThe BoS bit in the first MPLS shim header.

Prereqs:
OXM_OF_ETH_TYPE must match 0x8847 or 0x8848 exactly.

Format: 8-bit integer with 7 most-significant bits forced to 0.
Only the lowest bit have a meaning.

Masking: Not maskable.</text>
          </description>
        </leaf>
      </case>
      <case name="pbb_isid">
        <leaf name="pbb_isid">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_PBB_ISID   OXM_HEADER  (0x8000, OFPXMT_OFB_PBB_ISID, 3)
#define OXM_OF_PBB_ISID_W OXM_HEADER_W(0x8000, OFPXMT_OFB_PBB_ISID, 3)
For OFPXMT_OFB_PBB_ISIDIEEE 802.1ah I-SID.

For a packet with a PBB header, this is the I-SID from the
outermost service tag.

Prereqs:
OXM_OF_ETH_TYPE must match 0x88E7 exactly.

Format: 24-bit integer in network byte order.

Masking: Arbitrary masks.</text>
          </description>
        </leaf>
      </case>
      <case name="tunnel_id">
        <leaf name="tunnel_id">
          <type name="uint64"/>
          <description>
            <text>#define OXM_OF_TUNNEL_ID    OXM_HEADER  (0x8000, OFPXMT_OFB_TUNNEL_ID, 8)
#define OXM_OF_TUNNEL_ID_W  OXM_HEADER_W(0x8000, OFPXMT_OFB_TUNNEL_ID, 8)
For OFPXMT_OFB_TUNNEL_IDLogical Port Metadata.

Metadata associated with a logical port.
If the logical port performs encapsulation and decapsulation, this
is the demultiplexing field from the encapsulation header.
For example, for a packet received via GRE tunnel including a (32-bit) key,
the key is stored in the low 32-bits and the high bits are zeroed.
For a MPLS logical port, the low 20 bits represent the MPLS Label.
For a VxLAN logical port, the low 24 bits represent the VNI.
If the packet is not received through a logical port, the value is 0.

Prereqs: None.

Format: 64-bit integer in network byte order.

Masking: Arbitrary masks.</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_exthdr">
        <leaf name="ipv6_exthdr">
          <type name="uint32"/>
          <description>
            <text>#define OXM_OF_IPV6_EXTHDR   OXM_HEADER  (0x8000, OFPXMT_OFB_IPV6_EXTHDR, 2)
#define OXM_OF_IPV6_EXTHDR_W OXM_HEADER_W(0x8000, OFPXMT_OFB_IPV6_EXTHDR, 2)
For OFPXMT_OFB_IPV6_EXTHDRThe IPv6 Extension Header pseudo-field.

Prereqs:
OXM_OF_ETH_TYPE must match 0x86dd exactly

Format: 16-bit integer with 7 most-significant bits forced to 0.
Only the lower 9 bits have meaning.

Masking: Maskable.</text>
          </description>
        </leaf>
      </case>
    </choice>
    <choice name="choice_1">
      <case name="table_metadata_mask">
        <leaf name="table_metadata_mask">
          <type name="uint64"/>
          <description>
            <text>For OFPXMT_OFB_METADATA</text>
          </description>
        </leaf>
      </case>
      <case name="eth_dst_mask">
        <leaf name="eth_dst_mask">
          <type name="binary"/>
          <description>
            <text>For OFPXMT_OFB_ETH_DST (exactly 6 bytes)</text>
          </description>
        </leaf>
      </case>
      <case name="eth_src_mask">
        <leaf name="eth_src_mask">
          <type name="binary"/>
          <description>
            <text>For OFPXMT_OFB_ETH_SRC (exactly 6 bytes)</text>
          </description>
        </leaf>
      </case>
      <case name="vlan_vid_mask">
        <leaf name="vlan_vid_mask">
          <type name="uint32"/>
          <description>
            <text>For OFPXMT_OFB_VLAN_VID</text>
          </description>
        </leaf>
      </case>
      <case name="ipv4_src_mask">
        <leaf name="ipv4_src_mask">
          <type name="uint32"/>
          <description>
            <text>For OFPXMT_OFB_IPV4_SRC</text>
          </description>
        </leaf>
      </case>
      <case name="ipv4_dst_mask">
        <leaf name="ipv4_dst_mask">
          <type name="uint32"/>
          <description>
            <text>For OFPXMT_OFB_IPV4_DST</text>
          </description>
        </leaf>
      </case>
      <case name="arp_spa_mask">
        <leaf name="arp_spa_mask">
          <type name="uint32"/>
          <description>
            <text>For OFPXMT_OFB_ARP_SPA</text>
          </description>
        </leaf>
      </case>
      <case name="arp_tpa_mask">
        <leaf name="arp_tpa_mask">
          <type name="uint32"/>
          <description>
            <text>For OFPXMT_OFB_ARP_TPA</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_src_mask">
        <leaf name="ipv6_src_mask">
          <type name="binary"/>
          <description>
            <text>For OFPXMT_OFB_IPV6_SRC</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_dst_mask">
        <leaf name="ipv6_dst_mask">
          <type name="binary"/>
          <description>
            <text>For OFPXMT_OFB_IPV6_DST</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_flabel_mask">
        <leaf name="ipv6_flabel_mask">
          <type name="uint32"/>
          <description>
            <text>For OFPXMT_OFB_IPV6_FLABEL</text>
          </description>
        </leaf>
      </case>
      <case name="pbb_isid_mask">
        <leaf name="pbb_isid_mask">
          <type name="uint32"/>
          <description>
            <text>For OFPXMT_OFB_PBB_ISID</text>
          </description>
        </leaf>
      </case>
      <case name="tunnel_id_mask">
        <leaf name="tunnel_id_mask">
          <type name="uint64"/>
          <description>
            <text>For OFPXMT_OFB_TUNNEL_ID</text>
          </description>
        </leaf>
      </case>
      <case name="ipv6_exthdr_mask">
        <leaf name="ipv6_exthdr_mask">
          <type name="uint32"/>
          <description>
            <text>For OFPXMT_OFB_IPV6_EXTHDR</text>
          </description>
        </leaf>
      </case>
    </choice>
  </grouping>
  <grouping name="ofp_oxm_experimenter_field">
    <description>
      <text>Header for OXM experimenter match fields.
The experimenter class should not use OXM_HEADER() macros for defining
fields due to this extra header.</text>
    </description>
    <leaf name="oxm_header">
      <type name="uint32"/>
      <description>
        <text>oxm_class = OFPXMC_EXPERIMENTER</text>
      </description>
    </leaf>
    <leaf name="experimenter">
      <type name="uint32"/>
      <description>
        <text>Experimenter ID which takes the same
form as in struct ofp_experimenter_header.</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_action">
    <description>
      <text>Action header that is common to all actions.  The length includes the
header and any padding used to make the action 64-bit aligned.
NB: The length of an action  must  always be a multiple of eight.</text>
    </description>
    <leaf name="type">
      <type name="ofp_action_type"/>
      <description>
        <text>One of OFPAT_ .</text>
      </description>
    </leaf>
    <choice name="choice_0">
      <case name="output">
        <container name="output">
          <uses name="ofp_action_output"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="mpls_ttl">
        <container name="mpls_ttl">
          <uses name="ofp_action_mpls_ttl"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="push">
        <container name="push">
          <uses name="ofp_action_push"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="pop_mpls">
        <container name="pop_mpls">
          <uses name="ofp_action_pop_mpls"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="group">
        <container name="group">
          <uses name="ofp_action_group"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="nw_ttl">
        <container name="nw_ttl">
          <uses name="ofp_action_nw_ttl"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="set_field">
        <container name="set_field">
          <uses name="ofp_action_set_field"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="experimenter">
        <container name="experimenter">
          <uses name="ofp_action_experimenter"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
    </choice>
  </grouping>
  <grouping name="ofp_action_output">
    <description>
      <text>Action structure for OFPAT_OUTPUT, which sends packets out 'port'.
When the 'port' is the OFPP_CONTROLLER, 'max_len' indicates the max
number of bytes to send.  A 'max_len' of zero means no bytes of the
packet should be sent. A 'max_len' of OFPCML_NO_BUFFER means that
the packet is not buffered and the complete packet is to be sent to
the controller.</text>
    </description>
    <leaf name="port">
      <type name="uint32"/>
      <description>
        <text>Output port.</text>
      </description>
    </leaf>
    <leaf name="max_len">
      <type name="uint32"/>
      <description>
        <text>Max length to send to controller.</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_action_mpls_ttl">
    <description>
      <text>Action structure for OFPAT_SET_MPLS_TTL.</text>
    </description>
    <leaf name="mpls_ttl">
      <type name="uint32"/>
      <description>
        <text>MPLS TTL</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_action_push">
    <description>
      <text>Action structure for OFPAT_PUSH_VLAN MPLS PBB.</text>
    </description>
    <leaf name="ethertype">
      <type name="uint32"/>
      <description>
        <text>Ethertype</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_action_pop_mpls">
    <description>
      <text>Action structure for OFPAT_POP_MPLS.</text>
    </description>
    <leaf name="ethertype">
      <type name="uint32"/>
      <description>
        <text>Ethertype</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_action_group">
    <description>
      <text>Action structure for OFPAT_GROUP.</text>
    </description>
    <leaf name="group_id">
      <type name="uint32"/>
      <description>
        <text>Group identifier.</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_action_nw_ttl">
    <description>
      <text>Action structure for OFPAT_SET_NW_TTL.</text>
    </description>
    <leaf name="nw_ttl">
      <type name="uint32"/>
      <description>
        <text>IP TTL</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_action_set_field">
    <description>
      <text>Action structure for OFPAT_SET_FIELD.</text>
    </description>
    <container name="field">
      <uses name="ofp_oxm_field"/>
      <description>
        <text/>
      </description>
    </container>
  </grouping>
  <grouping name="ofp_action_experimenter">
    <description>
      <text>Action header for OFPAT_EXPERIMENTER.
The rest of the body is experimenter-defined.</text>
    </description>
    <leaf name="experimenter">
      <type name="uint32"/>
      <description>
        <text>Experimenter ID which takes the same
form as in struct
ofp_experimenter_header.</text>
      </description>
    </leaf>
    <leaf name="data">
      <type name="binary"/>
      <description>
        <text/>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_instruction">
    <description>
      <text>Instruction header that is common to all instructions.  The length includes
the header and any padding used to make the instruction 64-bit aligned.
NB: The length of an instruction  must  always be a multiple of eight.</text>
    </description>
    <leaf name="type">
      <type name="uint32"/>
      <description>
        <text>Instruction type</text>
      </description>
    </leaf>
    <choice name="choice_0">
      <case name="goto_table">
        <container name="goto_table">
          <uses name="ofp_instruction_goto_table"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="write_metadata">
        <container name="write_metadata">
          <uses name="ofp_instruction_write_metadata"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="actions">
        <container name="actions">
          <uses name="ofp_instruction_actions"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="meter">
        <container name="meter">
          <uses name="ofp_instruction_meter"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="experimenter">
        <container name="experimenter">
          <uses name="ofp_instruction_experimenter"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
    </choice>
  </grouping>
  <grouping name="ofp_instruction_goto_table">
    <description>
      <text>Instruction structure for OFPIT_GOTO_TABLE</text>
    </description>
    <leaf name="table_id">
      <type name="uint32"/>
      <description>
        <text>Set next table in the lookup pipeline</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_instruction_write_metadata">
    <description>
      <text>Instruction structure for OFPIT_WRITE_METADATA</text>
    </description>
    <leaf name="metadata">
      <type name="uint64"/>
      <description>
        <text>Metadata value to write</text>
      </description>
    </leaf>
    <leaf name="metadata_mask">
      <type name="uint64"/>
      <description>
        <text>Metadata write bitmask</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_instruction_actions">
    <description>
      <text>Instruction structure for OFPIT_WRITE APPLY CLEAR_ACTIONS</text>
    </description>
    <list name="actions">
      <key value="type"/>
      <uses name="ofp_action"/>
      <description>
        <text>0 or more actions associated
with OFPIT_WRITE_ACTIONS and
OFPIT_APPLY_ACTIONS</text>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_instruction_meter">
    <description>
      <text>Instruction structure for OFPIT_METER</text>
    </description>
    <leaf name="meter_id">
      <type name="uint32"/>
      <description>
        <text>Meter instance.</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_instruction_experimenter">
    <description>
      <text>Instruction structure for experimental instructions</text>
    </description>
    <leaf name="experimenter">
      <type name="uint32"/>
      <description>
        <text>Experimenter ID which takes the same form
as in struct ofp_experimenter_header.</text>
      </description>
    </leaf>
    <leaf name="data">
      <type name="binary"/>
      <description>
        <text>Experimenter-defined arbitrary additional data.</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_flow_mod">
    <description>
      <text>Flow setup and teardown (controller -  datapath).</text>
    </description>
    <leaf name="cookie">
      <type name="uint64"/>
      <description>
        <text>ofp_header header;
Opaque controller-issued identifier.</text>
      </description>
    </leaf>
    <leaf name="cookie_mask">
      <type name="uint64"/>
      <description>
        <text>Mask used to restrict the cookie bits
that must match when the command is
OFPFC_MODIFY  or OFPFC_DELETE . A value
of 0 indicates no restriction.</text>
      </description>
    </leaf>
    <leaf name="table_id">
      <type name="uint32"/>
      <description>
        <text>ID of the table to put the flow in.
For OFPFC_DELETE_  commands, OFPTT_ALL
can also be used to delete matching
flows from all tables.</text>
      </description>
    </leaf>
    <leaf name="command">
      <type name="ofp_flow_mod_command"/>
      <description>
        <text>One of OFPFC_ .</text>
      </description>
    </leaf>
    <leaf name="idle_timeout">
      <type name="uint32"/>
      <description>
        <text>Idle time before discarding (seconds).</text>
      </description>
    </leaf>
    <leaf name="hard_timeout">
      <type name="uint32"/>
      <description>
        <text>Max time before discarding (seconds).</text>
      </description>
    </leaf>
    <leaf name="priority">
      <type name="uint32"/>
      <description>
        <text>Priority level of flow entry.</text>
      </description>
    </leaf>
    <leaf name="buffer_id">
      <type name="uint32"/>
      <description>
        <text>Buffered packet to apply to, or
OFP_NO_BUFFER.
Not meaningful for OFPFC_DELETE .</text>
      </description>
    </leaf>
    <leaf name="out_port">
      <type name="uint32"/>
      <description>
        <text>For OFPFC_DELETE  commands, require
matching entries to include this as an
output port.  A value of OFPP_ANY
indicates no restriction.</text>
      </description>
    </leaf>
    <leaf name="out_group">
      <type name="uint32"/>
      <description>
        <text>For OFPFC_DELETE  commands, require
matching entries to include this as an
output group.  A value of OFPG_ANY
indicates no restriction.</text>
      </description>
    </leaf>
    <leaf name="flags">
      <type name="uint32"/>
      <description>
        <text>Bitmap of OFPFF_  flags.</text>
      </description>
    </leaf>
    <container name="match">
      <uses name="ofp_match"/>
      <description>
        <text>Fields to match. Variable size.</text>
      </description>
    </container>
    <list name="instructions">
      <key value="type"/>
      <uses name="ofp_instruction"/>
      <description>
        <text>0 or more.</text>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_bucket">
    <description>
      <text>Bucket for use in groups.</text>
    </description>
    <leaf name="weight">
      <type name="uint32"/>
      <description>
        <text>Relative weight of bucket.  Only
defined for select groups.</text>
      </description>
    </leaf>
    <leaf name="watch_port">
      <type name="uint32"/>
      <description>
        <text>Port whose state affects whether this
bucket is live.  Only required for fast
failover groups.</text>
      </description>
    </leaf>
    <leaf name="watch_group">
      <type name="uint32"/>
      <description>
        <text>Group whose state affects whether this
bucket is live.  Only required for fast
failover groups.</text>
      </description>
    </leaf>
    <list name="actions">
      <key value="type"/>
      <uses name="ofp_action"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_group_mod">
    <description>
      <text>Group setup and teardown (controller -  datapath).</text>
    </description>
    <leaf name="command">
      <type name="ofp_group_mod_command"/>
      <description>
        <text>ofp_header header;
One of OFPGC_ .</text>
      </description>
    </leaf>
    <leaf name="type">
      <type name="ofp_group_type"/>
      <description>
        <text>One of OFPGT_ .</text>
      </description>
    </leaf>
    <leaf name="group_id">
      <type name="uint32"/>
      <description>
        <text>Group identifier.</text>
      </description>
    </leaf>
    <list name="buckets">
      <key value="weight"/>
      <uses name="ofp_bucket"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_packet_out">
    <description>
      <text>Send packet (controller -  datapath).Special buffer-id to indicate 'no buffer'#define OFP_NO_BUFFER 0xffffffff</text>
    </description>
    <leaf name="buffer_id">
      <type name="uint32"/>
      <description>
        <text>ofp_header header;
ID assigned by datapath (OFP_NO_BUFFER
if none).</text>
      </description>
    </leaf>
    <leaf name="in_port">
      <type name="uint32"/>
      <description>
        <text>Packet's input port or OFPP_CONTROLLER.</text>
      </description>
    </leaf>
    <list name="actions">
      <key value="type"/>
      <uses name="ofp_action"/>
      <description>
        <text>Action list - 0 or more.</text>
      </description>
    </list>
    <leaf name="data">
      <type name="binary"/>
      <description>
        <text>The variable size action list is optionally followed by packet data.
This data is only present and meaningful if buffer_id == -1.Packet data.</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_packet_in">
    <description>
      <text>Packet received on port (datapath -  controller).</text>
    </description>
    <leaf name="buffer_id">
      <type name="uint32"/>
      <description>
        <text>ofp_header header;
ID assigned by datapath.</text>
      </description>
    </leaf>
    <leaf name="reason">
      <type name="ofp_packet_in_reason"/>
      <description>
        <text>Reason packet is being sent</text>
      </description>
    </leaf>
    <leaf name="table_id">
      <type name="uint32"/>
      <description>
        <text>ID of the table that was looked up</text>
      </description>
    </leaf>
    <leaf name="cookie">
      <type name="uint64"/>
      <description>
        <text>Cookie of the flow entry that was looked up.</text>
      </description>
    </leaf>
    <container name="match">
      <uses name="ofp_match"/>
      <description>
        <text>Packet metadata. Variable size.</text>
      </description>
    </container>
    <leaf name="data">
      <type name="binary"/>
      <description>
        <text>Ethernet frame</text>
      </description>
    </leaf>
  </grouping>
  <container name="ofp_flow_removed">
    <description>
      <text>Flow removed (datapath -  controller).</text>
    </description>
    <leaf name="cookie">
      <type name="uint64"/>
      <description>
        <text>ofp_header header;
Opaque controller-issued identifier.</text>
      </description>
    </leaf>
    <leaf name="priority">
      <type name="uint32"/>
      <description>
        <text>Priority level of flow entry.</text>
      </description>
    </leaf>
    <leaf name="reason">
      <type name="ofp_flow_removed_reason"/>
      <description>
        <text>One of OFPRR_ .</text>
      </description>
    </leaf>
    <leaf name="table_id">
      <type name="uint32"/>
      <description>
        <text>ID of the table</text>
      </description>
    </leaf>
    <leaf name="duration_sec">
      <type name="uint32"/>
      <description>
        <text>Time flow was alive in seconds.</text>
      </description>
    </leaf>
    <leaf name="duration_nsec">
      <type name="uint32"/>
      <description>
        <text>Time flow was alive in nanoseconds beyond
duration_sec.</text>
      </description>
    </leaf>
    <leaf name="idle_timeout">
      <type name="uint32"/>
      <description>
        <text>Idle timeout from original flow mod.</text>
      </description>
    </leaf>
    <leaf name="hard_timeout">
      <type name="uint32"/>
      <description>
        <text>Hard timeout from original flow mod.</text>
      </description>
    </leaf>
    <leaf name="packet_count">
      <type name="uint64"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="byte_count">
      <type name="uint64"/>
      <description>
        <text/>
      </description>
    </leaf>
    <container name="match">
      <uses name="ofp_match"/>
      <description>
        <text>Description of fields. Variable size.</text>
      </description>
    </container>
  </container>
  <grouping name="ofp_meter_band_header">
    <description>
      <text>Common header for all meter bands</text>
    </description>
    <leaf name="type">
      <type name="ofp_meter_band_type"/>
      <description>
        <text>One of OFPMBT_ .</text>
      </description>
    </leaf>
    <leaf name="len">
      <type name="uint32"/>
      <description>
        <text>Length in bytes of this band.</text>
      </description>
    </leaf>
    <leaf name="rate">
      <type name="uint32"/>
      <description>
        <text>Rate for this band.</text>
      </description>
    </leaf>
    <leaf name="burst_size">
      <type name="uint32"/>
      <description>
        <text>Size of bursts.</text>
      </description>
    </leaf>
  </grouping>
  <container name="ofp_meter_band_drop">
    <description>
      <text>OFPMBT_DROP band - drop packets</text>
    </description>
    <leaf name="type">
      <type name="uint32"/>
      <description>
        <text>OFPMBT_DROP.</text>
      </description>
    </leaf>
    <leaf name="len">
      <type name="uint32"/>
      <description>
        <text>Length in bytes of this band.</text>
      </description>
    </leaf>
    <leaf name="rate">
      <type name="uint32"/>
      <description>
        <text>Rate for dropping packets.</text>
      </description>
    </leaf>
    <leaf name="burst_size">
      <type name="uint32"/>
      <description>
        <text>Size of bursts.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_meter_band_dscp_remark">
    <description>
      <text>OFPMBT_DSCP_REMARK band - Remark DSCP in the IP header</text>
    </description>
    <leaf name="type">
      <type name="uint32"/>
      <description>
        <text>OFPMBT_DSCP_REMARK.</text>
      </description>
    </leaf>
    <leaf name="len">
      <type name="uint32"/>
      <description>
        <text>Length in bytes of this band.</text>
      </description>
    </leaf>
    <leaf name="rate">
      <type name="uint32"/>
      <description>
        <text>Rate for remarking packets.</text>
      </description>
    </leaf>
    <leaf name="burst_size">
      <type name="uint32"/>
      <description>
        <text>Size of bursts.</text>
      </description>
    </leaf>
    <leaf name="prec_level">
      <type name="uint32"/>
      <description>
        <text>Number of drop precedence level to add.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_meter_band_experimenter">
    <description>
      <text>OFPMBT_EXPERIMENTER band - Experimenter type.
The rest of the band is experimenter-defined.</text>
    </description>
    <leaf name="type">
      <type name="ofp_meter_band_type"/>
      <description>
        <text>One of OFPMBT_ .</text>
      </description>
    </leaf>
    <leaf name="len">
      <type name="uint32"/>
      <description>
        <text>Length in bytes of this band.</text>
      </description>
    </leaf>
    <leaf name="rate">
      <type name="uint32"/>
      <description>
        <text>Rate for this band.</text>
      </description>
    </leaf>
    <leaf name="burst_size">
      <type name="uint32"/>
      <description>
        <text>Size of bursts.</text>
      </description>
    </leaf>
    <leaf name="experimenter">
      <type name="uint32"/>
      <description>
        <text>Experimenter ID which takes the
same form as in struct
ofp_experimenter_header.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_meter_mod">
    <description>
      <text>Meter configuration. OFPT_METER_MOD.</text>
    </description>
    <leaf name="command">
      <type name="ofp_meter_mod_command"/>
      <description>
        <text>ofp_header   header = 1;
One of OFPMC_ .</text>
      </description>
    </leaf>
    <leaf name="flags">
      <type name="uint32"/>
      <description>
        <text>Bitmap of OFPMF_  flags.</text>
      </description>
    </leaf>
    <leaf name="meter_id">
      <type name="uint32"/>
      <description>
        <text>Meter instance.</text>
      </description>
    </leaf>
    <list name="bands">
      <key value="type"/>
      <uses name="ofp_meter_band_header"/>
      <description>
        <text>The band list length is
inferred from the length field
in the header.</text>
      </description>
    </list>
  </container>
  <container name="ofp_error_msg">
    <description>
      <text>OFPT_ERROR: Error message (datapath -  controller).</text>
    </description>
    <leaf name="type">
      <type name="uint32"/>
      <description>
        <text>ofp_header header;</text>
      </description>
    </leaf>
    <leaf name="code">
      <type name="uint32"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="data">
      <type name="binary"/>
      <description>
        <text>Variable-length data.  Interpreted based
on the type and code.  No padding.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_error_experimenter_msg">
    <description>
      <text>OFPET_EXPERIMENTER: Error message (datapath -  controller).ofp_header header;</text>
    </description>
    <leaf name="type">
      <type name="uint32"/>
      <description>
        <text>OFPET_EXPERIMENTER.</text>
      </description>
    </leaf>
    <leaf name="exp_type">
      <type name="uint32"/>
      <description>
        <text>Experimenter defined.</text>
      </description>
    </leaf>
    <leaf name="experimenter">
      <type name="uint32"/>
      <description>
        <text>Experimenter ID which takes the same form
as in struct ofp_experimenter_header.</text>
      </description>
    </leaf>
    <leaf name="data">
      <type name="binary"/>
      <description>
        <text>Variable-length data.  Interpreted based
on the type and code.  No padding.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_multipart_request">
    <description>
      <text/>
    </description>
    <leaf name="type">
      <type name="ofp_multipart_type"/>
      <description>
        <text>ofp_header header;
One of the OFPMP_  constants.</text>
      </description>
    </leaf>
    <leaf name="flags">
      <type name="uint32"/>
      <description>
        <text>OFPMPF_REQ_  flags.</text>
      </description>
    </leaf>
    <leaf name="body">
      <type name="binary"/>
      <description>
        <text>Body of the request. 0 or more bytes.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_multipart_reply">
    <description>
      <text/>
    </description>
    <leaf name="type">
      <type name="ofp_multipart_type"/>
      <description>
        <text>ofp_header header;
One of the OFPMP_  constants.</text>
      </description>
    </leaf>
    <leaf name="flags">
      <type name="uint32"/>
      <description>
        <text>OFPMPF_REPLY_  flags.</text>
      </description>
    </leaf>
    <leaf name="body">
      <type name="binary"/>
      <description>
        <text>Body of the reply. 0 or more bytes.</text>
      </description>
    </leaf>
  </container>
  <grouping name="ofp_desc">
    <description>
      <text>Body of reply to OFPMP_DESC request.  Each entry is a NULL-terminated
ASCII string.#define DESC_STR_LEN   256
#define SERIAL_NUM_LEN 32</text>
    </description>
    <leaf name="mfr_desc">
      <type name="string"/>
      <description>
        <text>Manufacturer description.</text>
      </description>
    </leaf>
    <leaf name="hw_desc">
      <type name="string"/>
      <description>
        <text>Hardware description.</text>
      </description>
    </leaf>
    <leaf name="sw_desc">
      <type name="string"/>
      <description>
        <text>Software description.</text>
      </description>
    </leaf>
    <leaf name="serial_num">
      <type name="string"/>
      <description>
        <text>Serial number.</text>
      </description>
    </leaf>
    <leaf name="dp_desc">
      <type name="string"/>
      <description>
        <text>Human readable description of datapath.</text>
      </description>
    </leaf>
  </grouping>
  <container name="ofp_flow_stats_request">
    <description>
      <text>Body for ofp_multipart_request of type OFPMP_FLOW.</text>
    </description>
    <leaf name="table_id">
      <type name="uint32"/>
      <description>
        <text>ID of table to read (from ofp_table_stats),
OFPTT_ALL for all tables.</text>
      </description>
    </leaf>
    <leaf name="out_port">
      <type name="uint32"/>
      <description>
        <text>Require matching entries to include this
as an output port.  A value of OFPP_ANY
indicates no restriction.</text>
      </description>
    </leaf>
    <leaf name="out_group">
      <type name="uint32"/>
      <description>
        <text>Require matching entries to include this
as an output group.  A value of OFPG_ANY
indicates no restriction.</text>
      </description>
    </leaf>
    <leaf name="cookie">
      <type name="uint64"/>
      <description>
        <text>Require matching entries to contain this
cookie value</text>
      </description>
    </leaf>
    <leaf name="cookie_mask">
      <type name="uint64"/>
      <description>
        <text>Mask used to restrict the cookie bits that
must match. A value of 0 indicates
no restriction.</text>
      </description>
    </leaf>
    <container name="match">
      <uses name="ofp_match"/>
      <description>
        <text>Fields to match. Variable size.</text>
      </description>
    </container>
  </container>
  <grouping name="ofp_flow_stats">
    <description>
      <text>Body of reply to OFPMP_FLOW request.</text>
    </description>
    <leaf name="id">
      <type name="uint64"/>
      <description>
        <text>Unique ID of flow within device.</text>
      </description>
    </leaf>
    <leaf name="table_id">
      <type name="uint32"/>
      <description>
        <text>ID of table flow came from.</text>
      </description>
    </leaf>
    <leaf name="duration_sec">
      <type name="uint32"/>
      <description>
        <text>Time flow has been alive in seconds.</text>
      </description>
    </leaf>
    <leaf name="duration_nsec">
      <type name="uint32"/>
      <description>
        <text>Time flow has been alive in nanoseconds
beyond duration_sec.</text>
      </description>
    </leaf>
    <leaf name="priority">
      <type name="uint32"/>
      <description>
        <text>Priority of the entry.</text>
      </description>
    </leaf>
    <leaf name="idle_timeout">
      <type name="uint32"/>
      <description>
        <text>Number of seconds idle before expiration.</text>
      </description>
    </leaf>
    <leaf name="hard_timeout">
      <type name="uint32"/>
      <description>
        <text>Number of seconds before expiration.</text>
      </description>
    </leaf>
    <leaf name="flags">
      <type name="uint32"/>
      <description>
        <text>Bitmap of OFPFF_  flags.</text>
      </description>
    </leaf>
    <leaf name="cookie">
      <type name="uint64"/>
      <description>
        <text>Opaque controller-issued identifier.</text>
      </description>
    </leaf>
    <leaf name="packet_count">
      <type name="uint64"/>
      <description>
        <text>Number of packets in flow.</text>
      </description>
    </leaf>
    <leaf name="byte_count">
      <type name="uint64"/>
      <description>
        <text>Number of bytes in flow.</text>
      </description>
    </leaf>
    <container name="match">
      <uses name="ofp_match"/>
      <description>
        <text>Description of fields. Variable size.</text>
      </description>
    </container>
    <list name="instructions">
      <key value="type"/>
      <uses name="ofp_instruction"/>
      <description>
        <text>Instruction set
(0 or more)</text>
      </description>
    </list>
  </grouping>
  <container name="ofp_aggregate_stats_request">
    <description>
      <text>Body for ofp_multipart_request of type OFPMP_AGGREGATE.</text>
    </description>
    <leaf name="table_id">
      <type name="uint32"/>
      <description>
        <text>ID of table to read (from ofp_table_stats)
OFPTT_ALL for all tables.</text>
      </description>
    </leaf>
    <leaf name="out_port">
      <type name="uint32"/>
      <description>
        <text>Require matching entries to include this
as an output port.  A value of OFPP_ANY
indicates no restriction.</text>
      </description>
    </leaf>
    <leaf name="out_group">
      <type name="uint32"/>
      <description>
        <text>Require matching entries to include this
as an output group.  A value of OFPG_ANY
indicates no restriction.</text>
      </description>
    </leaf>
    <leaf name="cookie">
      <type name="uint64"/>
      <description>
        <text>Require matching entries to contain this
cookie value</text>
      </description>
    </leaf>
    <leaf name="cookie_mask">
      <type name="uint64"/>
      <description>
        <text>Mask used to restrict the cookie bits that
must match. A value of 0 indicates
no restriction.</text>
      </description>
    </leaf>
    <container name="match">
      <uses name="ofp_match"/>
      <description>
        <text>Fields to match. Variable size.</text>
      </description>
    </container>
  </container>
  <container name="ofp_aggregate_stats_reply">
    <description>
      <text>Body of reply to OFPMP_AGGREGATE request.</text>
    </description>
    <leaf name="packet_count">
      <type name="uint64"/>
      <description>
        <text>Number of packets in flows.</text>
      </description>
    </leaf>
    <leaf name="byte_count">
      <type name="uint64"/>
      <description>
        <text>Number of bytes in flows.</text>
      </description>
    </leaf>
    <leaf name="flow_count">
      <type name="uint32"/>
      <description>
        <text>Number of flows.</text>
      </description>
    </leaf>
  </container>
  <grouping name="ofp_table_feature_property">
    <description>
      <text>Common header for all Table Feature Properties</text>
    </description>
    <leaf name="type">
      <type name="ofp_table_feature_prop_type"/>
      <description>
        <text>One of OFPTFPT_ .</text>
      </description>
    </leaf>
    <choice name="choice_0">
      <case name="instructions">
        <container name="instructions">
          <uses name="ofp_table_feature_prop_instructions"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="next_tables">
        <container name="next_tables">
          <uses name="ofp_table_feature_prop_next_tables"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="actions">
        <container name="actions">
          <uses name="ofp_table_feature_prop_actions"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="oxm">
        <container name="oxm">
          <uses name="ofp_table_feature_prop_oxm"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
      <case name="experimenter">
        <container name="experimenter">
          <uses name="ofp_table_feature_prop_experimenter"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
    </choice>
  </grouping>
  <grouping name="ofp_table_feature_prop_instructions">
    <description>
      <text>Instructions property</text>
    </description>
    <list name="instructions">
      <key value="type"/>
      <uses name="ofp_instruction"/>
      <description>
        <text>One of OFPTFPT_INSTRUCTIONS,
OFPTFPT_INSTRUCTIONS_MISS.List of instructions</text>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_table_feature_prop_next_tables">
    <description>
      <text>Next Tables property</text>
    </description>
    <list name="next_table_ids">
      <key value="next_table_ids"/>
      <leaf name="next_table_ids">
        <type name="uint32"/>
        <description>
          <text>One of OFPTFPT_NEXT_TABLES,
OFPTFPT_NEXT_TABLES_MISS.List of table ids.</text>
        </description>
      </leaf>
      <description>
        <text>One of OFPTFPT_NEXT_TABLES,
OFPTFPT_NEXT_TABLES_MISS.List of table ids.</text>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_table_feature_prop_actions">
    <description>
      <text>Actions property</text>
    </description>
    <list name="actions">
      <key value="type"/>
      <uses name="ofp_action"/>
      <description>
        <text>One of OFPTFPT_WRITE_ACTIONS,
OFPTFPT_WRITE_ACTIONS_MISS,
OFPTFPT_APPLY_ACTIONS,
OFPTFPT_APPLY_ACTIONS_MISS.List of actions</text>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_table_feature_prop_oxm">
    <description>
      <text>Match, Wildcard or Set-Field propertyOne of OFPTFPT_MATCH,
OFPTFPT_WILDCARDS,
OFPTFPT_WRITE_SETFIELD,
OFPTFPT_WRITE_SETFIELD_MISS,
OFPTFPT_APPLY_SETFIELD,
OFPTFPT_APPLY_SETFIELD_MISS.</text>
    </description>
    <list name="oxm_ids">
      <key value="oxm_ids"/>
      <leaf name="oxm_ids">
        <type name="uint32"/>
        <description>
          <text>TODO is this a uint32???Array of OXM headers</text>
        </description>
      </leaf>
      <description>
        <text>TODO is this a uint32???Array of OXM headers</text>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_table_feature_prop_experimenter">
    <description>
      <text>Experimenter table feature property</text>
    </description>
    <leaf name="experimenter">
      <type name="uint32"/>
      <description>
        <text>One of OFPTFPT_EXPERIMENTER,
OFPTFPT_EXPERIMENTER_MISS.Experimenter ID which takes the same
form as in struct
ofp_experimenter_header.</text>
      </description>
    </leaf>
    <leaf name="exp_type">
      <type name="uint32"/>
      <description>
        <text>Experimenter defined.</text>
      </description>
    </leaf>
    <list name="experimenter_data">
      <key value="experimenter_data"/>
      <leaf name="experimenter_data">
        <type name="uint32"/>
        <description>
          <text/>
        </description>
      </leaf>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <container name="ofp_table_features">
    <description>
      <text>Body for ofp_multipart_request of type OFPMP_TABLE_FEATURES.
Body of reply to OFPMP_TABLE_FEATURES request.</text>
    </description>
    <leaf name="table_id">
      <type name="uint32"/>
      <description>
        <text>Identifier of table.  Lower numbered tables
are consulted first.</text>
      </description>
    </leaf>
    <leaf name="name">
      <type name="string"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="metadata_match">
      <type name="uint64"/>
      <description>
        <text>Bits of metadata table can match.</text>
      </description>
    </leaf>
    <leaf name="metadata_write">
      <type name="uint64"/>
      <description>
        <text>Bits of metadata table can write.</text>
      </description>
    </leaf>
    <leaf name="config">
      <type name="uint32"/>
      <description>
        <text>Bitmap of OFPTC_  values</text>
      </description>
    </leaf>
    <leaf name="max_entries">
      <type name="uint32"/>
      <description>
        <text>Max number of entries supported.</text>
      </description>
    </leaf>
    <list name="properties">
      <key value="type"/>
      <uses name="ofp_table_feature_property"/>
      <description>
        <text>Table Feature Property list</text>
      </description>
    </list>
  </container>
  <container name="ofp_table_stats">
    <description>
      <text>Body of reply to OFPMP_TABLE request.</text>
    </description>
    <leaf name="table_id">
      <type name="uint32"/>
      <description>
        <text>Identifier of table.  Lower numbered tables
are consulted first.</text>
      </description>
    </leaf>
    <leaf name="active_count">
      <type name="uint32"/>
      <description>
        <text>Number of active entries.</text>
      </description>
    </leaf>
    <leaf name="lookup_count">
      <type name="uint64"/>
      <description>
        <text>Number of packets looked up in table.</text>
      </description>
    </leaf>
    <leaf name="matched_count">
      <type name="uint64"/>
      <description>
        <text>Number of packets that hit table.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_port_stats_request">
    <description>
      <text>Body for ofp_multipart_request of type OFPMP_PORT.</text>
    </description>
    <leaf name="port_no">
      <type name="uint32"/>
      <description>
        <text>OFPMP_PORT message must request statistics
either for a single port (specified in
port_no) or for all ports (if port_no ==
OFPP_ANY).</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_port_stats">
    <description>
      <text>Body of reply to OFPMP_PORT request. If a counter is unsupported, set
the field to all ones.</text>
    </description>
    <leaf name="port_no">
      <type name="uint32"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="rx_packets">
      <type name="uint64"/>
      <description>
        <text>Number of received packets.</text>
      </description>
    </leaf>
    <leaf name="tx_packets">
      <type name="uint64"/>
      <description>
        <text>Number of transmitted packets.</text>
      </description>
    </leaf>
    <leaf name="rx_bytes">
      <type name="uint64"/>
      <description>
        <text>Number of received bytes.</text>
      </description>
    </leaf>
    <leaf name="tx_bytes">
      <type name="uint64"/>
      <description>
        <text>Number of transmitted bytes.</text>
      </description>
    </leaf>
    <leaf name="rx_dropped">
      <type name="uint64"/>
      <description>
        <text>Number of packets dropped by RX.</text>
      </description>
    </leaf>
    <leaf name="tx_dropped">
      <type name="uint64"/>
      <description>
        <text>Number of packets dropped by TX.</text>
      </description>
    </leaf>
    <leaf name="rx_errors">
      <type name="uint64"/>
      <description>
        <text>Number of receive errors.  This is a super-set
of more specific receive errors and should be
greater than or equal to the sum of all
rx_ _err values.</text>
      </description>
    </leaf>
    <leaf name="tx_errors">
      <type name="uint64"/>
      <description>
        <text>Number of transmit errors.  This is a super-set
of more specific transmit errors and should be
greater than or equal to the sum of all
tx_ _err values (none currently defined.)</text>
      </description>
    </leaf>
    <leaf name="rx_frame_err">
      <type name="uint64"/>
      <description>
        <text>Number of frame alignment errors.</text>
      </description>
    </leaf>
    <leaf name="rx_over_err">
      <type name="uint64"/>
      <description>
        <text>Number of packets with RX overrun.</text>
      </description>
    </leaf>
    <leaf name="rx_crc_err">
      <type name="uint64"/>
      <description>
        <text>Number of CRC errors.</text>
      </description>
    </leaf>
    <leaf name="collisions">
      <type name="uint64"/>
      <description>
        <text>Number of collisions.</text>
      </description>
    </leaf>
    <leaf name="duration_sec">
      <type name="uint32"/>
      <description>
        <text>Time port has been alive in seconds.</text>
      </description>
    </leaf>
    <leaf name="duration_nsec">
      <type name="uint32"/>
      <description>
        <text>Time port has been alive in nanoseconds
beyond duration_sec.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_group_stats_request">
    <description>
      <text>Body of OFPMP_GROUP request.</text>
    </description>
    <leaf name="group_id">
      <type name="uint32"/>
      <description>
        <text>All groups if OFPG_ALL.</text>
      </description>
    </leaf>
  </container>
  <grouping name="ofp_bucket_counter">
    <description>
      <text>Used in group stats replies.</text>
    </description>
    <leaf name="packet_count">
      <type name="uint64"/>
      <description>
        <text>Number of packets processed by bucket.</text>
      </description>
    </leaf>
    <leaf name="byte_count">
      <type name="uint64"/>
      <description>
        <text>Number of bytes processed by bucket.</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="ofp_group_stats">
    <description>
      <text>Body of reply to OFPMP_GROUP request.</text>
    </description>
    <leaf name="group_id">
      <type name="uint32"/>
      <description>
        <text>Group identifier.</text>
      </description>
    </leaf>
    <leaf name="ref_count">
      <type name="uint32"/>
      <description>
        <text>Number of flows or groups that directly
forward to this group.</text>
      </description>
    </leaf>
    <leaf name="packet_count">
      <type name="uint64"/>
      <description>
        <text>Number of packets processed by group.</text>
      </description>
    </leaf>
    <leaf name="byte_count">
      <type name="uint64"/>
      <description>
        <text>Number of bytes processed by group.</text>
      </description>
    </leaf>
    <leaf name="duration_sec">
      <type name="uint32"/>
      <description>
        <text>Time group has been alive in seconds.</text>
      </description>
    </leaf>
    <leaf name="duration_nsec">
      <type name="uint32"/>
      <description>
        <text>Time group has been alive in nanoseconds
beyond duration_sec.</text>
      </description>
    </leaf>
    <list name="bucket_stats">
      <key value="packet_count"/>
      <uses name="ofp_bucket_counter"/>
      <description>
        <text>One counter set per
bucket.</text>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_group_desc">
    <description>
      <text>Body of reply to OFPMP_GROUP_DESC request.</text>
    </description>
    <leaf name="type">
      <type name="ofp_group_type"/>
      <description>
        <text>One of OFPGT_ .</text>
      </description>
    </leaf>
    <leaf name="group_id">
      <type name="uint32"/>
      <description>
        <text>Group identifier.</text>
      </description>
    </leaf>
    <list name="buckets">
      <key value="weight"/>
      <uses name="ofp_bucket"/>
      <description>
        <text>List of buckets - 0 or more.</text>
      </description>
    </list>
  </grouping>
  <grouping name="ofp_group_entry">
    <description>
      <text/>
    </description>
    <leaf name="type">
      <type name="ofp_group_type"/>
      <description>
        <text>One of OFPGT_ .</text>
      </description>
    </leaf>
    <leaf name="group_id">
      <type name="uint32"/>
      <description>
        <text>Group identifier.</text>
      </description>
    </leaf>
    <list name="buckets">
      <key value="weight"/>
      <uses name="ofp_bucket"/>
      <description>
        <text>List of buckets - 0 or more.</text>
      </description>
    </list>
    <container name="stats">
      <uses name="ofp_group_stats"/>
      <description>
        <text/>
      </description>
    </container>
  </grouping>
  <container name="ofp_group_features">
    <description>
      <text>Body of reply to OFPMP_GROUP_FEATURES request. Group features.</text>
    </description>
    <leaf name="types">
      <type name="uint32"/>
      <description>
        <text>Bitmap of (1    OFPGT_ ) values supported.</text>
      </description>
    </leaf>
    <leaf name="capabilities">
      <type name="uint32"/>
      <description>
        <text>Bitmap of OFPGFC_  capability supported.</text>
      </description>
    </leaf>
    <list name="max_groups">
      <key value="max_groups"/>
      <leaf name="max_groups">
        <type name="uint32"/>
        <description>
          <text>Maximum number of groups for each type.</text>
        </description>
      </leaf>
      <description>
        <text>Maximum number of groups for each type.</text>
      </description>
    </list>
    <list name="actions">
      <key value="actions"/>
      <leaf name="actions">
        <type name="uint32"/>
        <description>
          <text>Bitmaps of (1    OFPAT_ ) values
supported.</text>
        </description>
      </leaf>
      <description>
        <text>Bitmaps of (1    OFPAT_ ) values
supported.</text>
      </description>
    </list>
  </container>
  <container name="ofp_meter_multipart_request">
    <description>
      <text>Body of OFPMP_METER and OFPMP_METER_CONFIG requests.</text>
    </description>
    <leaf name="meter_id">
      <type name="uint32"/>
      <description>
        <text>Meter instance, or OFPM_ALL.</text>
      </description>
    </leaf>
  </container>
  <grouping name="ofp_meter_band_stats">
    <description>
      <text>Statistics for each meter band</text>
    </description>
    <leaf name="packet_band_count">
      <type name="uint64"/>
      <description>
        <text>Number of packets in band.</text>
      </description>
    </leaf>
    <leaf name="byte_band_count">
      <type name="uint64"/>
      <description>
        <text>Number of bytes in band.</text>
      </description>
    </leaf>
  </grouping>
  <container name="ofp_meter_stats">
    <description>
      <text>Body of reply to OFPMP_METER request. Meter statistics.</text>
    </description>
    <leaf name="meter_id">
      <type name="uint32"/>
      <description>
        <text>Meter instance.</text>
      </description>
    </leaf>
    <leaf name="flow_count">
      <type name="uint32"/>
      <description>
        <text>Number of flows bound to meter.</text>
      </description>
    </leaf>
    <leaf name="packet_in_count">
      <type name="uint64"/>
      <description>
        <text>Number of packets in input.</text>
      </description>
    </leaf>
    <leaf name="byte_in_count">
      <type name="uint64"/>
      <description>
        <text>Number of bytes in input.</text>
      </description>
    </leaf>
    <leaf name="duration_sec">
      <type name="uint32"/>
      <description>
        <text>Time meter has been alive in seconds.</text>
      </description>
    </leaf>
    <leaf name="duration_nsec">
      <type name="uint32"/>
      <description>
        <text>Time meter has been alive in nanoseconds
beyond duration_sec.</text>
      </description>
    </leaf>
    <list name="band_stats">
      <key value="packet_band_count"/>
      <uses name="ofp_meter_band_stats"/>
      <description>
        <text>The band_stats length is
inferred from the length field.</text>
      </description>
    </list>
  </container>
  <container name="ofp_meter_config">
    <description>
      <text>Body of reply to OFPMP_METER_CONFIG request. Meter configuration.</text>
    </description>
    <leaf name="flags">
      <type name="uint32"/>
      <description>
        <text>All OFPMF_  that apply.</text>
      </description>
    </leaf>
    <leaf name="meter_id">
      <type name="uint32"/>
      <description>
        <text>Meter instance.</text>
      </description>
    </leaf>
    <list name="bands">
      <key value="type"/>
      <uses name="ofp_meter_band_header"/>
      <description>
        <text>The bands length is
inferred from the length field.</text>
      </description>
    </list>
  </container>
  <container name="ofp_meter_features">
    <description>
      <text>Body of reply to OFPMP_METER_FEATURES request. Meter features.</text>
    </description>
    <leaf name="max_meter">
      <type name="uint32"/>
      <description>
        <text>Maximum number of meters.</text>
      </description>
    </leaf>
    <leaf name="band_types">
      <type name="uint32"/>
      <description>
        <text>Bitmaps of (1    OFPMBT_ ) values supported.</text>
      </description>
    </leaf>
    <leaf name="capabilities">
      <type name="uint32"/>
      <description>
        <text>Bitmaps of  ofp_meter_flags .</text>
      </description>
    </leaf>
    <leaf name="max_bands">
      <type name="uint32"/>
      <description>
        <text>Maximum bands per meters</text>
      </description>
    </leaf>
    <leaf name="max_color">
      <type name="uint32"/>
      <description>
        <text>Maximum color value</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_experimenter_multipart_header">
    <description>
      <text>Body for ofp_multipart_request reply of type OFPMP_EXPERIMENTER.</text>
    </description>
    <leaf name="experimenter">
      <type name="uint32"/>
      <description>
        <text>Experimenter ID which takes the same form
as in struct ofp_experimenter_header.</text>
      </description>
    </leaf>
    <leaf name="exp_type">
      <type name="uint32"/>
      <description>
        <text>Experimenter defined.</text>
      </description>
    </leaf>
    <leaf name="data">
      <type name="binary"/>
      <description>
        <text>Experimenter-defined arbitrary additional data.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_experimenter_header">
    <description>
      <text>Experimenter extension.</text>
    </description>
    <leaf name="experimenter">
      <type name="uint32"/>
      <description>
        <text>ofp_header header;     Type OFPT_EXPERIMENTER.
Experimenter ID:
- MSB 0: low-order bytes are IEEE OUI.
- MSB != 0: defined by ONF.</text>
      </description>
    </leaf>
    <leaf name="exp_type">
      <type name="uint32"/>
      <description>
        <text>Experimenter defined.</text>
      </description>
    </leaf>
    <leaf name="data">
      <type name="binary"/>
      <description>
        <text>Experimenter-defined arbitrary additional data.</text>
      </description>
    </leaf>
  </container>
  <grouping name="ofp_queue_prop_header">
    <description>
      <text>Common description for a queue.</text>
    </description>
    <leaf name="property">
      <type name="uint32"/>
      <description>
        <text>One of OFPQT_.</text>
      </description>
    </leaf>
    <leaf name="len">
      <type name="uint32"/>
      <description>
        <text>Length of property, including this header.</text>
      </description>
    </leaf>
  </grouping>
  <container name="ofp_queue_prop_min_rate">
    <description>
      <text>Min-Rate queue property description.</text>
    </description>
    <container name="prop_header">
      <uses name="ofp_queue_prop_header"/>
      <description>
        <text>prop: OFPQT_MIN, len: 16.</text>
      </description>
    </container>
    <leaf name="rate">
      <type name="uint32"/>
      <description>
        <text>In 1 10 of a percent = 0; 1000 -  disabled.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_queue_prop_max_rate">
    <description>
      <text>Max-Rate queue property description.</text>
    </description>
    <container name="prop_header">
      <uses name="ofp_queue_prop_header"/>
      <description>
        <text>prop: OFPQT_MAX, len: 16.</text>
      </description>
    </container>
    <leaf name="rate">
      <type name="uint32"/>
      <description>
        <text>In 1 10 of a percent = 0; 1000 -  disabled.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_queue_prop_experimenter">
    <description>
      <text>Experimenter queue property description.</text>
    </description>
    <container name="prop_header">
      <uses name="ofp_queue_prop_header"/>
      <description>
        <text>prop: OFPQT_EXPERIMENTER</text>
      </description>
    </container>
    <leaf name="experimenter">
      <type name="uint32"/>
      <description>
        <text>Experimenter ID which takes the same
form as in struct
ofp_experimenter_header.</text>
      </description>
    </leaf>
    <leaf name="data">
      <type name="binary"/>
      <description>
        <text>Experimenter defined data.</text>
      </description>
    </leaf>
  </container>
  <grouping name="ofp_packet_queue">
    <description>
      <text>Full description for a queue.</text>
    </description>
    <leaf name="queue_id">
      <type name="uint32"/>
      <description>
        <text>id for the specific queue.</text>
      </description>
    </leaf>
    <leaf name="port">
      <type name="uint32"/>
      <description>
        <text>Port this queue is attached to.</text>
      </description>
    </leaf>
    <list name="properties">
      <key value="property"/>
      <uses name="ofp_queue_prop_header"/>
      <description>
        <text>List of properties.</text>
      </description>
    </list>
  </grouping>
  <container name="ofp_queue_get_config_request">
    <description>
      <text>Query for port queue configuration.</text>
    </description>
    <leaf name="port">
      <type name="uint32"/>
      <description>
        <text>ofp_header header;
Port to be queried. Should refer
to a valid physical port (i.e.  = OFPP_MAX),
or OFPP_ANY to request all configured
queues.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_queue_get_config_reply">
    <description>
      <text>Queue configuration for a given port.</text>
    </description>
    <leaf name="port">
      <type name="uint32"/>
      <description>
        <text>ofp_header header;</text>
      </description>
    </leaf>
    <list name="queues">
      <key value="queue_id"/>
      <uses name="ofp_packet_queue"/>
      <description>
        <text>List of configured queues.</text>
      </description>
    </list>
  </container>
  <container name="ofp_action_set_queue">
    <description>
      <text>OFPAT_SET_QUEUE action struct: send packets to given queue on port.</text>
    </description>
    <leaf name="type">
      <type name="uint32"/>
      <description>
        <text>OFPAT_SET_QUEUE.</text>
      </description>
    </leaf>
    <leaf name="queue_id">
      <type name="uint32"/>
      <description>
        <text>Queue id for the packets.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_queue_stats_request">
    <description>
      <text/>
    </description>
    <leaf name="port_no">
      <type name="uint32"/>
      <description>
        <text>All ports if OFPP_ANY.</text>
      </description>
    </leaf>
    <leaf name="queue_id">
      <type name="uint32"/>
      <description>
        <text>All queues if OFPQ_ALL.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_queue_stats">
    <description>
      <text/>
    </description>
    <leaf name="port_no">
      <type name="uint32"/>
      <description>
        <text/>
      </description>
    </leaf>
    <leaf name="queue_id">
      <type name="uint32"/>
      <description>
        <text>Queue i.d</text>
      </description>
    </leaf>
    <leaf name="tx_bytes">
      <type name="uint64"/>
      <description>
        <text>Number of transmitted bytes.</text>
      </description>
    </leaf>
    <leaf name="tx_packets">
      <type name="uint64"/>
      <description>
        <text>Number of transmitted packets.</text>
      </description>
    </leaf>
    <leaf name="tx_errors">
      <type name="uint64"/>
      <description>
        <text>Number of packets dropped due to overrun.</text>
      </description>
    </leaf>
    <leaf name="duration_sec">
      <type name="uint32"/>
      <description>
        <text>Time queue has been alive in seconds.</text>
      </description>
    </leaf>
    <leaf name="duration_nsec">
      <type name="uint32"/>
      <description>
        <text>Time queue has been alive in nanoseconds
beyond duration_sec.</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_role_request">
    <description>
      <text>Role request and reply message.</text>
    </description>
    <leaf name="role">
      <type name="ofp_controller_role"/>
      <description>
        <text>ofp_header header;           Type OFPT_ROLE_REQUEST OFPT_ROLE_REPLY.
One of OFPCR_ROLE_ .</text>
      </description>
    </leaf>
    <leaf name="generation_id">
      <type name="uint64"/>
      <description>
        <text>Master Election Generation Id</text>
      </description>
    </leaf>
  </container>
  <container name="ofp_async_config">
    <description>
      <text>Asynchronous message configuration.</text>
    </description>
    <list name="packet_in_mask">
      <key value="packet_in_mask"/>
      <leaf name="packet_in_mask">
        <type name="uint32"/>
        <description>
          <text>ofp_header header;       OFPT_GET_ASYNC_REPLY or OFPT_SET_ASYNC.
Bitmasks of OFPR_  values.</text>
        </description>
      </leaf>
      <description>
        <text>ofp_header header;       OFPT_GET_ASYNC_REPLY or OFPT_SET_ASYNC.
Bitmasks of OFPR_  values.</text>
      </description>
    </list>
    <list name="port_status_mask">
      <key value="port_status_mask"/>
      <leaf name="port_status_mask">
        <type name="uint32"/>
        <description>
          <text>Bitmasks of OFPPR_  values.</text>
        </description>
      </leaf>
      <description>
        <text>Bitmasks of OFPPR_  values.</text>
      </description>
    </list>
    <list name="flow_removed_mask">
      <key value="flow_removed_mask"/>
      <leaf name="flow_removed_mask">
        <type name="uint32"/>
        <description>
          <text>Bitmasks of OFPRR_  values.</text>
        </description>
      </leaf>
      <description>
        <text>Bitmasks of OFPRR_  values.</text>
      </description>
    </list>
  </container>
  <grouping name="FlowTableUpdate">
    <description>
      <text>ADDITIONAL VOLTHA SPECIFIC MESSAGE TYPES, AIDING RPC CALLS</text>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text>Device.id or LogicalDevice.id</text>
      </description>
    </leaf>
    <container name="flow_mod">
      <uses name="ofp_flow_mod"/>
      <description>
        <text/>
      </description>
    </container>
  </grouping>
  <grouping name="FlowGroupTableUpdate">
    <description>
      <text/>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text>Device.id or LogicalDevice.id</text>
      </description>
    </leaf>
    <container name="group_mod">
      <uses name="ofp_group_mod"/>
      <description>
        <text/>
      </description>
    </container>
  </grouping>
  <grouping name="Flows">
    <description>
      <text/>
    </description>
    <list name="items">
      <key value="id"/>
      <uses name="ofp_flow_stats"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="FlowGroups">
    <description>
      <text/>
    </description>
    <list name="items">
      <key value="type"/>
      <uses name="ofp_group_entry"/>
      <description>
        <text/>
      </description>
    </list>
  </grouping>
  <grouping name="PacketIn">
    <description>
      <text/>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text>LogicalDevice.id</text>
      </description>
    </leaf>
    <container name="packet_in">
      <uses name="ofp_packet_in"/>
      <description>
        <text/>
      </description>
    </container>
  </grouping>
  <grouping name="PacketOut">
    <description>
      <text/>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text>LogicalDevice.id</text>
      </description>
    </leaf>
    <container name="packet_out">
      <uses name="ofp_packet_out"/>
      <description>
        <text/>
      </description>
    </container>
  </grouping>
  <grouping name="ChangeEvent">
    <description>
      <text/>
    </description>
    <leaf name="id">
      <type name="string"/>
      <description>
        <text>LogicalDevice.id</text>
      </description>
    </leaf>
    <choice name="choice_0">
      <case name="port_status">
        <container name="port_status">
          <uses name="ofp_port_status"/>
          <description>
            <text/>
          </description>
        </container>
      </case>
    </choice>
  </grouping>
  <rpc name="HealthService-GetHealthStatus">
    <description>
      <text>Return current health status of a Voltha instance</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="HealthStatus"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-GetVoltha">
    <description>
      <text>Get high level information on the Voltha cluster</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="Voltha_grouping"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListVolthaInstances">
    <description>
      <text>List all Voltha cluster instances</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="VolthaInstances_grouping"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-GetVolthaInstance">
    <description>
      <text>Get details on a Voltha cluster instance</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="VolthaInstance_grouping"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListLogicalDevices">
    <description>
      <text>List all logical devices managed by the Voltha cluster</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="LogicalDevices"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-GetLogicalDevice">
    <description>
      <text>Get additional information on a given logical device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="LogicalDevice"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListLogicalDevicePorts">
    <description>
      <text>List ports of a logical device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="LogicalPorts"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListLogicalDeviceFlows">
    <description>
      <text>List all flows of a logical device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Flows"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-UpdateLogicalDeviceFlowTable">
    <description>
      <text>Update flow table for logical device</text>
    </description>
    <input>
      <uses name="FlowTableUpdate"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListLogicalDeviceFlowGroups">
    <description>
      <text>List all flow groups of a logical device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="FlowGroups"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-UpdateLogicalDeviceFlowGroupTable">
    <description>
      <text>Update group table for device</text>
    </description>
    <input>
      <uses name="FlowGroupTableUpdate"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListDevices">
    <description>
      <text>List all physical devices controlled by the Voltha cluster</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="Devices"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-GetDevice">
    <description>
      <text>Get more information on a given physical device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Device"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-CreateDevice">
    <description>
      <text>Pre-provision a new physical device</text>
    </description>
    <input>
      <uses name="Device"/>
    </input>
    <output>
      <uses name="Device"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-EnableDevice">
    <description>
      <text>Enable a device.  If the device was in pre-provisioned state then it
will tansition to ENABLED state.  If it was is DISABLED state then it
will tansition to ENABLED state as well.</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-DisableDevice">
    <description>
      <text>Disable a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-RebootDevice">
    <description>
      <text>Reboot a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-DeleteDevice">
    <description>
      <text>Delete a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListDevicePorts">
    <description>
      <text>List ports of a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Ports"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListDevicePmConfigs">
    <description>
      <text>List pm config of a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="PmConfigs"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-UpdateDevicePmConfigs">
    <description>
      <text>Update the pm config of a device</text>
    </description>
    <input>
      <uses name="PmConfigs"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListDeviceFlows">
    <description>
      <text>List all flows of a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Flows"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListDeviceFlowGroups">
    <description>
      <text>List all flow groups of a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="FlowGroups"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListDeviceTypes">
    <description>
      <text>List device types known to Voltha</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="DeviceTypes"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-GetDeviceType">
    <description>
      <text>Get additional information on a device type</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="DeviceType"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListDeviceGroups">
    <description>
      <text>List all device sharding groups</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="DeviceGroups"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-GetDeviceGroup">
    <description>
      <text>Get additional information on a device group</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="DeviceGroup"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-CreateAlarmFilter">
    <description>
      <text/>
    </description>
    <input>
      <uses name="AlarmFilter"/>
    </input>
    <output>
      <uses name="AlarmFilter"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-GetAlarmFilter">
    <description>
      <text/>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="AlarmFilter"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-UpdateAlarmFilter">
    <description>
      <text/>
    </description>
    <input>
      <uses name="AlarmFilter"/>
    </input>
    <output>
      <uses name="AlarmFilter"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-DeleteAlarmFilter">
    <description>
      <text/>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaGlobalService-ListAlarmFilters">
    <description>
      <text/>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="AlarmFilters"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-GetVolthaInstance">
    <description>
      <text>Get information on this Voltha instance</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="VolthaInstance_grouping"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-GetHealth">
    <description>
      <text>Get the health state of the Voltha instance</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="HealthStatus"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListAdapters">
    <description>
      <text>List all active adapters (plugins) in this Voltha instance</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="Adapters"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListLogicalDevices">
    <description>
      <text>List all logical devices managed by this Voltha instance</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="LogicalDevices"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-GetLogicalDevice">
    <description>
      <text>Get additional information on given logical device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="LogicalDevice"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListLogicalDevicePorts">
    <description>
      <text>List ports of a logical device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="LogicalPorts"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListLogicalDeviceFlows">
    <description>
      <text>List all flows of a logical device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Flows"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-UpdateLogicalDeviceFlowTable">
    <description>
      <text>Update flow table for logical device</text>
    </description>
    <input>
      <uses name="FlowTableUpdate"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListLogicalDeviceFlowGroups">
    <description>
      <text>List all flow groups of a logical device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="FlowGroups"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-UpdateLogicalDeviceFlowGroupTable">
    <description>
      <text>Update group table for logical device</text>
    </description>
    <input>
      <uses name="FlowGroupTableUpdate"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListDevices">
    <description>
      <text>List all physical devices managed by this Voltha instance</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="Devices"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-GetDevice">
    <description>
      <text>Get additional information on this device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Device"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-CreateDevice">
    <description>
      <text>Pre-provision a new physical device</text>
    </description>
    <input>
      <uses name="Device"/>
    </input>
    <output>
      <uses name="Device"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-EnableDevice">
    <description>
      <text>Enable a device.  If the device was in pre-provisioned state then it
will tansition to ENABLED state.  If it was is DISABLED state then it
will tansition to ENABLED state as well.</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-DisableDevice">
    <description>
      <text>Disable a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-RebootDevice">
    <description>
      <text>Reboot a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-DeleteDevice">
    <description>
      <text>Delete a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListDevicePorts">
    <description>
      <text>List ports of a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Ports"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListDevicePmConfigs">
    <description>
      <text>List pm config of a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="PmConfigs"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-UpdateDevicePmConfigs">
    <description>
      <text>Update the pm config of a device</text>
    </description>
    <input>
      <uses name="PmConfigs"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListDeviceFlows">
    <description>
      <text>List all flows of a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Flows"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListDeviceFlowGroups">
    <description>
      <text>List all flow groups of a device</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="FlowGroups"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListDeviceTypes">
    <description>
      <text>List device types know to Voltha instance</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="DeviceTypes"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-GetDeviceType">
    <description>
      <text>Get additional information on given device type</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="DeviceType"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListDeviceGroups">
    <description>
      <text>List device sharding groups managed by this Voltha instance</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="DeviceGroups"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-GetDeviceGroup">
    <description>
      <text>Get more information on given device shard</text>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="DeviceGroup"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-StreamPacketsOut">
    <description>
      <text>Stream control packets to the dataplane
This does not have an HTTP representation</text>
    </description>
    <input>
      <uses name="PacketOut"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ReceivePacketsIn">
    <description>
      <text>Receive control packet stream
This does not have an HTTP representation</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="PacketIn"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ReceiveChangeEvents">
    <description>
      <text>This does not have an HTTP representation</text>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="ChangeEvent"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-CreateAlarmFilter">
    <description>
      <text/>
    </description>
    <input>
      <uses name="AlarmFilter"/>
    </input>
    <output>
      <uses name="AlarmFilter"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-GetAlarmFilter">
    <description>
      <text/>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="AlarmFilter"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-UpdateAlarmFilter">
    <description>
      <text/>
    </description>
    <input>
      <uses name="AlarmFilter"/>
    </input>
    <output>
      <uses name="AlarmFilter"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-DeleteAlarmFilter">
    <description>
      <text/>
    </description>
    <input>
      <uses name="ID"/>
    </input>
    <output>
      <uses name="Empty"/>
    </output>
  </rpc>
  <rpc name="VolthaLocalService-ListAlarmFilters">
    <description>
      <text/>
    </description>
    <input>
      <uses name="Empty"/>
    </input>
    <output>
      <uses name="AlarmFilters"/>
    </output>
  </rpc>
</module>
